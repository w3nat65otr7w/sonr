// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package didv1

import (
	fmt "fmt"
	io "io"
	reflect "reflect"
	sort "sort"
	sync "sync"

	_ "cosmossdk.io/api/amino"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

var (
	md_VerificationMethod                          protoreflect.MessageDescriptor
	fd_VerificationMethod_id                       protoreflect.FieldDescriptor
	fd_VerificationMethod_verification_method_kind protoreflect.FieldDescriptor
	fd_VerificationMethod_controller               protoreflect.FieldDescriptor
	fd_VerificationMethod_public_key_jwk           protoreflect.FieldDescriptor
	fd_VerificationMethod_public_key_multibase     protoreflect.FieldDescriptor
	fd_VerificationMethod_public_key_base58        protoreflect.FieldDescriptor
	fd_VerificationMethod_public_key_base64        protoreflect.FieldDescriptor
	fd_VerificationMethod_public_key_pem           protoreflect.FieldDescriptor
	fd_VerificationMethod_public_key_hex           protoreflect.FieldDescriptor
	fd_VerificationMethod_webauthn_credential      protoreflect.FieldDescriptor
	fd_VerificationMethod_blockchain_account_id    protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_VerificationMethod = File_did_v1_types_proto.Messages().ByName("VerificationMethod")
	fd_VerificationMethod_id = md_VerificationMethod.Fields().ByName("id")
	fd_VerificationMethod_verification_method_kind = md_VerificationMethod.Fields().ByName("verification_method_kind")
	fd_VerificationMethod_controller = md_VerificationMethod.Fields().ByName("controller")
	fd_VerificationMethod_public_key_jwk = md_VerificationMethod.Fields().ByName("public_key_jwk")
	fd_VerificationMethod_public_key_multibase = md_VerificationMethod.Fields().ByName("public_key_multibase")
	fd_VerificationMethod_public_key_base58 = md_VerificationMethod.Fields().ByName("public_key_base58")
	fd_VerificationMethod_public_key_base64 = md_VerificationMethod.Fields().ByName("public_key_base64")
	fd_VerificationMethod_public_key_pem = md_VerificationMethod.Fields().ByName("public_key_pem")
	fd_VerificationMethod_public_key_hex = md_VerificationMethod.Fields().ByName("public_key_hex")
	fd_VerificationMethod_webauthn_credential = md_VerificationMethod.Fields().ByName("webauthn_credential")
	fd_VerificationMethod_blockchain_account_id = md_VerificationMethod.Fields().ByName("blockchain_account_id")
}

var _ protoreflect.Message = (*fastReflection_VerificationMethod)(nil)

type fastReflection_VerificationMethod VerificationMethod

func (x *VerificationMethod) ProtoReflect() protoreflect.Message {
	return (*fastReflection_VerificationMethod)(x)
}

func (x *VerificationMethod) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_VerificationMethod_messageType fastReflection_VerificationMethod_messageType
var _ protoreflect.MessageType = fastReflection_VerificationMethod_messageType{}

type fastReflection_VerificationMethod_messageType struct{}

func (x fastReflection_VerificationMethod_messageType) Zero() protoreflect.Message {
	return (*fastReflection_VerificationMethod)(nil)
}
func (x fastReflection_VerificationMethod_messageType) New() protoreflect.Message {
	return new(fastReflection_VerificationMethod)
}
func (x fastReflection_VerificationMethod_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_VerificationMethod
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_VerificationMethod) Descriptor() protoreflect.MessageDescriptor {
	return md_VerificationMethod
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_VerificationMethod) Type() protoreflect.MessageType {
	return _fastReflection_VerificationMethod_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_VerificationMethod) New() protoreflect.Message {
	return new(fastReflection_VerificationMethod)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_VerificationMethod) Interface() protoreflect.ProtoMessage {
	return (*VerificationMethod)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_VerificationMethod) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != "" {
		value := protoreflect.ValueOfString(x.Id)
		if !f(fd_VerificationMethod_id, value) {
			return
		}
	}
	if x.VerificationMethodKind != "" {
		value := protoreflect.ValueOfString(x.VerificationMethodKind)
		if !f(fd_VerificationMethod_verification_method_kind, value) {
			return
		}
	}
	if x.Controller != "" {
		value := protoreflect.ValueOfString(x.Controller)
		if !f(fd_VerificationMethod_controller, value) {
			return
		}
	}
	if x.PublicKeyJwk != "" {
		value := protoreflect.ValueOfString(x.PublicKeyJwk)
		if !f(fd_VerificationMethod_public_key_jwk, value) {
			return
		}
	}
	if x.PublicKeyMultibase != "" {
		value := protoreflect.ValueOfString(x.PublicKeyMultibase)
		if !f(fd_VerificationMethod_public_key_multibase, value) {
			return
		}
	}
	if x.PublicKeyBase58 != "" {
		value := protoreflect.ValueOfString(x.PublicKeyBase58)
		if !f(fd_VerificationMethod_public_key_base58, value) {
			return
		}
	}
	if x.PublicKeyBase64 != "" {
		value := protoreflect.ValueOfString(x.PublicKeyBase64)
		if !f(fd_VerificationMethod_public_key_base64, value) {
			return
		}
	}
	if x.PublicKeyPem != "" {
		value := protoreflect.ValueOfString(x.PublicKeyPem)
		if !f(fd_VerificationMethod_public_key_pem, value) {
			return
		}
	}
	if x.PublicKeyHex != "" {
		value := protoreflect.ValueOfString(x.PublicKeyHex)
		if !f(fd_VerificationMethod_public_key_hex, value) {
			return
		}
	}
	if x.WebauthnCredential != nil {
		value := protoreflect.ValueOfMessage(x.WebauthnCredential.ProtoReflect())
		if !f(fd_VerificationMethod_webauthn_credential, value) {
			return
		}
	}
	if x.BlockchainAccountId != "" {
		value := protoreflect.ValueOfString(x.BlockchainAccountId)
		if !f(fd_VerificationMethod_blockchain_account_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_VerificationMethod) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.VerificationMethod.id":
		return x.Id != ""
	case "did.v1.VerificationMethod.verification_method_kind":
		return x.VerificationMethodKind != ""
	case "did.v1.VerificationMethod.controller":
		return x.Controller != ""
	case "did.v1.VerificationMethod.public_key_jwk":
		return x.PublicKeyJwk != ""
	case "did.v1.VerificationMethod.public_key_multibase":
		return x.PublicKeyMultibase != ""
	case "did.v1.VerificationMethod.public_key_base58":
		return x.PublicKeyBase58 != ""
	case "did.v1.VerificationMethod.public_key_base64":
		return x.PublicKeyBase64 != ""
	case "did.v1.VerificationMethod.public_key_pem":
		return x.PublicKeyPem != ""
	case "did.v1.VerificationMethod.public_key_hex":
		return x.PublicKeyHex != ""
	case "did.v1.VerificationMethod.webauthn_credential":
		return x.WebauthnCredential != nil
	case "did.v1.VerificationMethod.blockchain_account_id":
		return x.BlockchainAccountId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethod"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethod does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethod) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.VerificationMethod.id":
		x.Id = ""
	case "did.v1.VerificationMethod.verification_method_kind":
		x.VerificationMethodKind = ""
	case "did.v1.VerificationMethod.controller":
		x.Controller = ""
	case "did.v1.VerificationMethod.public_key_jwk":
		x.PublicKeyJwk = ""
	case "did.v1.VerificationMethod.public_key_multibase":
		x.PublicKeyMultibase = ""
	case "did.v1.VerificationMethod.public_key_base58":
		x.PublicKeyBase58 = ""
	case "did.v1.VerificationMethod.public_key_base64":
		x.PublicKeyBase64 = ""
	case "did.v1.VerificationMethod.public_key_pem":
		x.PublicKeyPem = ""
	case "did.v1.VerificationMethod.public_key_hex":
		x.PublicKeyHex = ""
	case "did.v1.VerificationMethod.webauthn_credential":
		x.WebauthnCredential = nil
	case "did.v1.VerificationMethod.blockchain_account_id":
		x.BlockchainAccountId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethod"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethod does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_VerificationMethod) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.VerificationMethod.id":
		value := x.Id
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.verification_method_kind":
		value := x.VerificationMethodKind
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.controller":
		value := x.Controller
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.public_key_jwk":
		value := x.PublicKeyJwk
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.public_key_multibase":
		value := x.PublicKeyMultibase
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.public_key_base58":
		value := x.PublicKeyBase58
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.public_key_base64":
		value := x.PublicKeyBase64
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.public_key_pem":
		value := x.PublicKeyPem
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.public_key_hex":
		value := x.PublicKeyHex
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethod.webauthn_credential":
		value := x.WebauthnCredential
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "did.v1.VerificationMethod.blockchain_account_id":
		value := x.BlockchainAccountId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethod"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethod does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethod) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.VerificationMethod.id":
		x.Id = value.Interface().(string)
	case "did.v1.VerificationMethod.verification_method_kind":
		x.VerificationMethodKind = value.Interface().(string)
	case "did.v1.VerificationMethod.controller":
		x.Controller = value.Interface().(string)
	case "did.v1.VerificationMethod.public_key_jwk":
		x.PublicKeyJwk = value.Interface().(string)
	case "did.v1.VerificationMethod.public_key_multibase":
		x.PublicKeyMultibase = value.Interface().(string)
	case "did.v1.VerificationMethod.public_key_base58":
		x.PublicKeyBase58 = value.Interface().(string)
	case "did.v1.VerificationMethod.public_key_base64":
		x.PublicKeyBase64 = value.Interface().(string)
	case "did.v1.VerificationMethod.public_key_pem":
		x.PublicKeyPem = value.Interface().(string)
	case "did.v1.VerificationMethod.public_key_hex":
		x.PublicKeyHex = value.Interface().(string)
	case "did.v1.VerificationMethod.webauthn_credential":
		x.WebauthnCredential = value.Message().Interface().(*WebAuthnCredential)
	case "did.v1.VerificationMethod.blockchain_account_id":
		x.BlockchainAccountId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethod"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethod does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethod) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.VerificationMethod.webauthn_credential":
		if x.WebauthnCredential == nil {
			x.WebauthnCredential = new(WebAuthnCredential)
		}
		return protoreflect.ValueOfMessage(x.WebauthnCredential.ProtoReflect())
	case "did.v1.VerificationMethod.id":
		panic(fmt.Errorf("field id of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.verification_method_kind":
		panic(fmt.Errorf("field verification_method_kind of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.controller":
		panic(fmt.Errorf("field controller of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.public_key_jwk":
		panic(fmt.Errorf("field public_key_jwk of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.public_key_multibase":
		panic(fmt.Errorf("field public_key_multibase of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.public_key_base58":
		panic(fmt.Errorf("field public_key_base58 of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.public_key_base64":
		panic(fmt.Errorf("field public_key_base64 of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.public_key_pem":
		panic(fmt.Errorf("field public_key_pem of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.public_key_hex":
		panic(fmt.Errorf("field public_key_hex of message did.v1.VerificationMethod is not mutable"))
	case "did.v1.VerificationMethod.blockchain_account_id":
		panic(fmt.Errorf("field blockchain_account_id of message did.v1.VerificationMethod is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethod"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethod does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_VerificationMethod) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.VerificationMethod.id":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.verification_method_kind":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.controller":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.public_key_jwk":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.public_key_multibase":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.public_key_base58":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.public_key_base64":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.public_key_pem":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.public_key_hex":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethod.webauthn_credential":
		m := new(WebAuthnCredential)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "did.v1.VerificationMethod.blockchain_account_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethod"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethod does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_VerificationMethod) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.VerificationMethod", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_VerificationMethod) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethod) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_VerificationMethod) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_VerificationMethod) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*VerificationMethod)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Id)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.VerificationMethodKind)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Controller)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKeyJwk)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKeyMultibase)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKeyBase58)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKeyBase64)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKeyPem)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKeyHex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.WebauthnCredential != nil {
			l = options.Size(x.WebauthnCredential)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockchainAccountId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*VerificationMethod)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.BlockchainAccountId) > 0 {
			i -= len(x.BlockchainAccountId)
			copy(dAtA[i:], x.BlockchainAccountId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockchainAccountId)))
			i--
			dAtA[i] = 0x5a
		}
		if x.WebauthnCredential != nil {
			encoded, err := options.Marshal(x.WebauthnCredential)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.PublicKeyHex) > 0 {
			i -= len(x.PublicKeyHex)
			copy(dAtA[i:], x.PublicKeyHex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKeyHex)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.PublicKeyPem) > 0 {
			i -= len(x.PublicKeyPem)
			copy(dAtA[i:], x.PublicKeyPem)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKeyPem)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.PublicKeyBase64) > 0 {
			i -= len(x.PublicKeyBase64)
			copy(dAtA[i:], x.PublicKeyBase64)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKeyBase64)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.PublicKeyBase58) > 0 {
			i -= len(x.PublicKeyBase58)
			copy(dAtA[i:], x.PublicKeyBase58)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKeyBase58)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.PublicKeyMultibase) > 0 {
			i -= len(x.PublicKeyMultibase)
			copy(dAtA[i:], x.PublicKeyMultibase)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKeyMultibase)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.PublicKeyJwk) > 0 {
			i -= len(x.PublicKeyJwk)
			copy(dAtA[i:], x.PublicKeyJwk)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKeyJwk)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Controller) > 0 {
			i -= len(x.Controller)
			copy(dAtA[i:], x.Controller)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Controller)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.VerificationMethodKind) > 0 {
			i -= len(x.VerificationMethodKind)
			copy(dAtA[i:], x.VerificationMethodKind)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VerificationMethodKind)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Id) > 0 {
			i -= len(x.Id)
			copy(dAtA[i:], x.Id)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Id)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*VerificationMethod)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: VerificationMethod: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: VerificationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Id = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VerificationMethodKind", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VerificationMethodKind = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Controller = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKeyJwk", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKeyJwk = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKeyMultibase", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKeyMultibase = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBase58", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKeyBase58 = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBase64", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKeyBase64 = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKeyPem", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKeyPem = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKeyHex", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKeyHex = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WebauthnCredential", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.WebauthnCredential == nil {
					x.WebauthnCredential = &WebAuthnCredential{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.WebauthnCredential); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockchainAccountId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockchainAccountId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_VerificationMethodReference                              protoreflect.MessageDescriptor
	fd_VerificationMethodReference_verification_method_id       protoreflect.FieldDescriptor
	fd_VerificationMethodReference_embedded_verification_method protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_VerificationMethodReference = File_did_v1_types_proto.Messages().ByName("VerificationMethodReference")
	fd_VerificationMethodReference_verification_method_id = md_VerificationMethodReference.Fields().ByName("verification_method_id")
	fd_VerificationMethodReference_embedded_verification_method = md_VerificationMethodReference.Fields().ByName("embedded_verification_method")
}

var _ protoreflect.Message = (*fastReflection_VerificationMethodReference)(nil)

type fastReflection_VerificationMethodReference VerificationMethodReference

func (x *VerificationMethodReference) ProtoReflect() protoreflect.Message {
	return (*fastReflection_VerificationMethodReference)(x)
}

func (x *VerificationMethodReference) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_VerificationMethodReference_messageType fastReflection_VerificationMethodReference_messageType
var _ protoreflect.MessageType = fastReflection_VerificationMethodReference_messageType{}

type fastReflection_VerificationMethodReference_messageType struct{}

func (x fastReflection_VerificationMethodReference_messageType) Zero() protoreflect.Message {
	return (*fastReflection_VerificationMethodReference)(nil)
}
func (x fastReflection_VerificationMethodReference_messageType) New() protoreflect.Message {
	return new(fastReflection_VerificationMethodReference)
}
func (x fastReflection_VerificationMethodReference_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_VerificationMethodReference
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_VerificationMethodReference) Descriptor() protoreflect.MessageDescriptor {
	return md_VerificationMethodReference
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_VerificationMethodReference) Type() protoreflect.MessageType {
	return _fastReflection_VerificationMethodReference_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_VerificationMethodReference) New() protoreflect.Message {
	return new(fastReflection_VerificationMethodReference)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_VerificationMethodReference) Interface() protoreflect.ProtoMessage {
	return (*VerificationMethodReference)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_VerificationMethodReference) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.VerificationMethodId != "" {
		value := protoreflect.ValueOfString(x.VerificationMethodId)
		if !f(fd_VerificationMethodReference_verification_method_id, value) {
			return
		}
	}
	if x.EmbeddedVerificationMethod != nil {
		value := protoreflect.ValueOfMessage(x.EmbeddedVerificationMethod.ProtoReflect())
		if !f(fd_VerificationMethodReference_embedded_verification_method, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_VerificationMethodReference) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.VerificationMethodReference.verification_method_id":
		return x.VerificationMethodId != ""
	case "did.v1.VerificationMethodReference.embedded_verification_method":
		return x.EmbeddedVerificationMethod != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethodReference"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethodReference does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethodReference) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.VerificationMethodReference.verification_method_id":
		x.VerificationMethodId = ""
	case "did.v1.VerificationMethodReference.embedded_verification_method":
		x.EmbeddedVerificationMethod = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethodReference"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethodReference does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_VerificationMethodReference) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.VerificationMethodReference.verification_method_id":
		value := x.VerificationMethodId
		return protoreflect.ValueOfString(value)
	case "did.v1.VerificationMethodReference.embedded_verification_method":
		value := x.EmbeddedVerificationMethod
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethodReference"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethodReference does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethodReference) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.VerificationMethodReference.verification_method_id":
		x.VerificationMethodId = value.Interface().(string)
	case "did.v1.VerificationMethodReference.embedded_verification_method":
		x.EmbeddedVerificationMethod = value.Message().Interface().(*VerificationMethod)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethodReference"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethodReference does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethodReference) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.VerificationMethodReference.embedded_verification_method":
		if x.EmbeddedVerificationMethod == nil {
			x.EmbeddedVerificationMethod = new(VerificationMethod)
		}
		return protoreflect.ValueOfMessage(x.EmbeddedVerificationMethod.ProtoReflect())
	case "did.v1.VerificationMethodReference.verification_method_id":
		panic(fmt.Errorf("field verification_method_id of message did.v1.VerificationMethodReference is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethodReference"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethodReference does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_VerificationMethodReference) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.VerificationMethodReference.verification_method_id":
		return protoreflect.ValueOfString("")
	case "did.v1.VerificationMethodReference.embedded_verification_method":
		m := new(VerificationMethod)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.VerificationMethodReference"))
		}
		panic(fmt.Errorf("message did.v1.VerificationMethodReference does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_VerificationMethodReference) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.VerificationMethodReference", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_VerificationMethodReference) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VerificationMethodReference) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_VerificationMethodReference) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_VerificationMethodReference) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*VerificationMethodReference)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.VerificationMethodId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.EmbeddedVerificationMethod != nil {
			l = options.Size(x.EmbeddedVerificationMethod)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*VerificationMethodReference)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.EmbeddedVerificationMethod != nil {
			encoded, err := options.Marshal(x.EmbeddedVerificationMethod)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.VerificationMethodId) > 0 {
			i -= len(x.VerificationMethodId)
			copy(dAtA[i:], x.VerificationMethodId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VerificationMethodId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*VerificationMethodReference)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: VerificationMethodReference: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: VerificationMethodReference: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VerificationMethodId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VerificationMethodId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EmbeddedVerificationMethod", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.EmbeddedVerificationMethod == nil {
					x.EmbeddedVerificationMethod = &VerificationMethod{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.EmbeddedVerificationMethod); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.Map = (*_Service_6_map)(nil)

type _Service_6_map struct {
	m *map[string]string
}

func (x *_Service_6_map) Len() int {
	if x.m == nil {
		return 0
	}
	return len(*x.m)
}

func (x *_Service_6_map) Range(f func(protoreflect.MapKey, protoreflect.Value) bool) {
	if x.m == nil {
		return
	}
	for k, v := range *x.m {
		mapKey := (protoreflect.MapKey)(protoreflect.ValueOfString(k))
		mapValue := protoreflect.ValueOfString(v)
		if !f(mapKey, mapValue) {
			break
		}
	}
}

func (x *_Service_6_map) Has(key protoreflect.MapKey) bool {
	if x.m == nil {
		return false
	}
	keyUnwrapped := key.String()
	concreteValue := keyUnwrapped
	_, ok := (*x.m)[concreteValue]
	return ok
}

func (x *_Service_6_map) Clear(key protoreflect.MapKey) {
	if x.m == nil {
		return
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	delete(*x.m, concreteKey)
}

func (x *_Service_6_map) Get(key protoreflect.MapKey) protoreflect.Value {
	if x.m == nil {
		return protoreflect.Value{}
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	v, ok := (*x.m)[concreteKey]
	if !ok {
		return protoreflect.Value{}
	}
	return protoreflect.ValueOfString(v)
}

func (x *_Service_6_map) Set(key protoreflect.MapKey, value protoreflect.Value) {
	if !key.IsValid() || !value.IsValid() {
		panic("invalid key or value provided")
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.m)[concreteKey] = concreteValue
}

func (x *_Service_6_map) Mutable(key protoreflect.MapKey) protoreflect.Value {
	panic("should not call Mutable on protoreflect.Map whose value is not of type protoreflect.Message")
}

func (x *_Service_6_map) NewValue() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_Service_6_map) IsValid() bool {
	return x.m != nil
}

var (
	md_Service                    protoreflect.MessageDescriptor
	fd_Service_id                 protoreflect.FieldDescriptor
	fd_Service_service_kind       protoreflect.FieldDescriptor
	fd_Service_single_endpoint    protoreflect.FieldDescriptor
	fd_Service_multiple_endpoints protoreflect.FieldDescriptor
	fd_Service_complex_endpoint   protoreflect.FieldDescriptor
	fd_Service_properties         protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_Service = File_did_v1_types_proto.Messages().ByName("Service")
	fd_Service_id = md_Service.Fields().ByName("id")
	fd_Service_service_kind = md_Service.Fields().ByName("service_kind")
	fd_Service_single_endpoint = md_Service.Fields().ByName("single_endpoint")
	fd_Service_multiple_endpoints = md_Service.Fields().ByName("multiple_endpoints")
	fd_Service_complex_endpoint = md_Service.Fields().ByName("complex_endpoint")
	fd_Service_properties = md_Service.Fields().ByName("properties")
}

var _ protoreflect.Message = (*fastReflection_Service)(nil)

type fastReflection_Service Service

func (x *Service) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Service)(x)
}

func (x *Service) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Service_messageType fastReflection_Service_messageType
var _ protoreflect.MessageType = fastReflection_Service_messageType{}

type fastReflection_Service_messageType struct{}

func (x fastReflection_Service_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Service)(nil)
}
func (x fastReflection_Service_messageType) New() protoreflect.Message {
	return new(fastReflection_Service)
}
func (x fastReflection_Service_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Service
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Service) Descriptor() protoreflect.MessageDescriptor {
	return md_Service
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Service) Type() protoreflect.MessageType {
	return _fastReflection_Service_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Service) New() protoreflect.Message {
	return new(fastReflection_Service)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Service) Interface() protoreflect.ProtoMessage {
	return (*Service)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Service) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != "" {
		value := protoreflect.ValueOfString(x.Id)
		if !f(fd_Service_id, value) {
			return
		}
	}
	if x.ServiceKind != "" {
		value := protoreflect.ValueOfString(x.ServiceKind)
		if !f(fd_Service_service_kind, value) {
			return
		}
	}
	if x.SingleEndpoint != "" {
		value := protoreflect.ValueOfString(x.SingleEndpoint)
		if !f(fd_Service_single_endpoint, value) {
			return
		}
	}
	if x.MultipleEndpoints != nil {
		value := protoreflect.ValueOfMessage(x.MultipleEndpoints.ProtoReflect())
		if !f(fd_Service_multiple_endpoints, value) {
			return
		}
	}
	if len(x.ComplexEndpoint) != 0 {
		value := protoreflect.ValueOfBytes(x.ComplexEndpoint)
		if !f(fd_Service_complex_endpoint, value) {
			return
		}
	}
	if len(x.Properties) != 0 {
		value := protoreflect.ValueOfMap(&_Service_6_map{m: &x.Properties})
		if !f(fd_Service_properties, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Service) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.Service.id":
		return x.Id != ""
	case "did.v1.Service.service_kind":
		return x.ServiceKind != ""
	case "did.v1.Service.single_endpoint":
		return x.SingleEndpoint != ""
	case "did.v1.Service.multiple_endpoints":
		return x.MultipleEndpoints != nil
	case "did.v1.Service.complex_endpoint":
		return len(x.ComplexEndpoint) != 0
	case "did.v1.Service.properties":
		return len(x.Properties) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.Service"))
		}
		panic(fmt.Errorf("message did.v1.Service does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Service) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.Service.id":
		x.Id = ""
	case "did.v1.Service.service_kind":
		x.ServiceKind = ""
	case "did.v1.Service.single_endpoint":
		x.SingleEndpoint = ""
	case "did.v1.Service.multiple_endpoints":
		x.MultipleEndpoints = nil
	case "did.v1.Service.complex_endpoint":
		x.ComplexEndpoint = nil
	case "did.v1.Service.properties":
		x.Properties = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.Service"))
		}
		panic(fmt.Errorf("message did.v1.Service does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Service) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.Service.id":
		value := x.Id
		return protoreflect.ValueOfString(value)
	case "did.v1.Service.service_kind":
		value := x.ServiceKind
		return protoreflect.ValueOfString(value)
	case "did.v1.Service.single_endpoint":
		value := x.SingleEndpoint
		return protoreflect.ValueOfString(value)
	case "did.v1.Service.multiple_endpoints":
		value := x.MultipleEndpoints
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "did.v1.Service.complex_endpoint":
		value := x.ComplexEndpoint
		return protoreflect.ValueOfBytes(value)
	case "did.v1.Service.properties":
		if len(x.Properties) == 0 {
			return protoreflect.ValueOfMap(&_Service_6_map{})
		}
		mapValue := &_Service_6_map{m: &x.Properties}
		return protoreflect.ValueOfMap(mapValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.Service"))
		}
		panic(fmt.Errorf("message did.v1.Service does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Service) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.Service.id":
		x.Id = value.Interface().(string)
	case "did.v1.Service.service_kind":
		x.ServiceKind = value.Interface().(string)
	case "did.v1.Service.single_endpoint":
		x.SingleEndpoint = value.Interface().(string)
	case "did.v1.Service.multiple_endpoints":
		x.MultipleEndpoints = value.Message().Interface().(*ServiceEndpoints)
	case "did.v1.Service.complex_endpoint":
		x.ComplexEndpoint = value.Bytes()
	case "did.v1.Service.properties":
		mv := value.Map()
		cmv := mv.(*_Service_6_map)
		x.Properties = *cmv.m
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.Service"))
		}
		panic(fmt.Errorf("message did.v1.Service does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Service) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.Service.multiple_endpoints":
		if x.MultipleEndpoints == nil {
			x.MultipleEndpoints = new(ServiceEndpoints)
		}
		return protoreflect.ValueOfMessage(x.MultipleEndpoints.ProtoReflect())
	case "did.v1.Service.properties":
		if x.Properties == nil {
			x.Properties = make(map[string]string)
		}
		value := &_Service_6_map{m: &x.Properties}
		return protoreflect.ValueOfMap(value)
	case "did.v1.Service.id":
		panic(fmt.Errorf("field id of message did.v1.Service is not mutable"))
	case "did.v1.Service.service_kind":
		panic(fmt.Errorf("field service_kind of message did.v1.Service is not mutable"))
	case "did.v1.Service.single_endpoint":
		panic(fmt.Errorf("field single_endpoint of message did.v1.Service is not mutable"))
	case "did.v1.Service.complex_endpoint":
		panic(fmt.Errorf("field complex_endpoint of message did.v1.Service is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.Service"))
		}
		panic(fmt.Errorf("message did.v1.Service does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Service) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.Service.id":
		return protoreflect.ValueOfString("")
	case "did.v1.Service.service_kind":
		return protoreflect.ValueOfString("")
	case "did.v1.Service.single_endpoint":
		return protoreflect.ValueOfString("")
	case "did.v1.Service.multiple_endpoints":
		m := new(ServiceEndpoints)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "did.v1.Service.complex_endpoint":
		return protoreflect.ValueOfBytes(nil)
	case "did.v1.Service.properties":
		m := make(map[string]string)
		return protoreflect.ValueOfMap(&_Service_6_map{m: &m})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.Service"))
		}
		panic(fmt.Errorf("message did.v1.Service does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Service) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.Service", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Service) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Service) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Service) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Service) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Service)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Id)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ServiceKind)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SingleEndpoint)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MultipleEndpoints != nil {
			l = options.Size(x.MultipleEndpoints)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ComplexEndpoint)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Properties) > 0 {
			SiZeMaP := func(k string, v string) {
				mapEntrySize := 1 + len(k) + runtime.Sov(uint64(len(k))) + 1 + len(v) + runtime.Sov(uint64(len(v)))
				n += mapEntrySize + 1 + runtime.Sov(uint64(mapEntrySize))
			}
			if options.Deterministic {
				sortme := make([]string, 0, len(x.Properties))
				for k := range x.Properties {
					sortme = append(sortme, k)
				}
				sort.Strings(sortme)
				for _, k := range sortme {
					v := x.Properties[k]
					SiZeMaP(k, v)
				}
			} else {
				for k, v := range x.Properties {
					SiZeMaP(k, v)
				}
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Service)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Properties) > 0 {
			MaRsHaLmAp := func(k string, v string) (protoiface.MarshalOutput, error) {
				baseI := i
				i -= len(v)
				copy(dAtA[i:], v)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
				i -= len(k)
				copy(dAtA[i:], k)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(k)))
				i--
				dAtA[i] = 0xa
				i = runtime.EncodeVarint(dAtA, i, uint64(baseI-i))
				i--
				dAtA[i] = 0x32
				return protoiface.MarshalOutput{}, nil
			}
			if options.Deterministic {
				keysForProperties := make([]string, 0, len(x.Properties))
				for k := range x.Properties {
					keysForProperties = append(keysForProperties, string(k))
				}
				sort.Slice(keysForProperties, func(i, j int) bool {
					return keysForProperties[i] < keysForProperties[j]
				})
				for iNdEx := len(keysForProperties) - 1; iNdEx >= 0; iNdEx-- {
					v := x.Properties[string(keysForProperties[iNdEx])]
					out, err := MaRsHaLmAp(keysForProperties[iNdEx], v)
					if err != nil {
						return out, err
					}
				}
			} else {
				for k := range x.Properties {
					v := x.Properties[k]
					out, err := MaRsHaLmAp(k, v)
					if err != nil {
						return out, err
					}
				}
			}
		}
		if len(x.ComplexEndpoint) > 0 {
			i -= len(x.ComplexEndpoint)
			copy(dAtA[i:], x.ComplexEndpoint)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ComplexEndpoint)))
			i--
			dAtA[i] = 0x2a
		}
		if x.MultipleEndpoints != nil {
			encoded, err := options.Marshal(x.MultipleEndpoints)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.SingleEndpoint) > 0 {
			i -= len(x.SingleEndpoint)
			copy(dAtA[i:], x.SingleEndpoint)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SingleEndpoint)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.ServiceKind) > 0 {
			i -= len(x.ServiceKind)
			copy(dAtA[i:], x.ServiceKind)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ServiceKind)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Id) > 0 {
			i -= len(x.Id)
			copy(dAtA[i:], x.Id)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Id)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Service)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Service: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Id = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ServiceKind", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ServiceKind = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SingleEndpoint", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SingleEndpoint = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MultipleEndpoints", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.MultipleEndpoints == nil {
					x.MultipleEndpoints = &ServiceEndpoints{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MultipleEndpoints); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ComplexEndpoint", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ComplexEndpoint = append(x.ComplexEndpoint[:0], dAtA[iNdEx:postIndex]...)
				if x.ComplexEndpoint == nil {
					x.ComplexEndpoint = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Properties == nil {
					x.Properties = make(map[string]string)
				}
				var mapkey string
				var mapvalue string
				for iNdEx < postIndex {
					entryPreIndex := iNdEx
					var wire uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						wire |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					fieldNum := int32(wire >> 3)
					if fieldNum == 1 {
						var stringLenmapkey uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapkey |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapkey := int(stringLenmapkey)
						if intStringLenmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapkey := iNdEx + intStringLenmapkey
						if postStringIndexmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapkey > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
						iNdEx = postStringIndexmapkey
					} else if fieldNum == 2 {
						var stringLenmapvalue uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapvalue |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapvalue := int(stringLenmapvalue)
						if intStringLenmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapvalue := iNdEx + intStringLenmapvalue
						if postStringIndexmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapvalue > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
						iNdEx = postStringIndexmapvalue
					} else {
						iNdEx = entryPreIndex
						skippy, err := runtime.Skip(dAtA[iNdEx:])
						if err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						if (skippy < 0) || (iNdEx+skippy) < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if (iNdEx + skippy) > postIndex {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						iNdEx += skippy
					}
				}
				x.Properties[mapkey] = mapvalue
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ServiceEndpoints_1_list)(nil)

type _ServiceEndpoints_1_list struct {
	list *[]string
}

func (x *_ServiceEndpoints_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ServiceEndpoints_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_ServiceEndpoints_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_ServiceEndpoints_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_ServiceEndpoints_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message ServiceEndpoints at list field Endpoints as it is not of Message kind"))
}

func (x *_ServiceEndpoints_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_ServiceEndpoints_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_ServiceEndpoints_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ServiceEndpoints           protoreflect.MessageDescriptor
	fd_ServiceEndpoints_endpoints protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_ServiceEndpoints = File_did_v1_types_proto.Messages().ByName("ServiceEndpoints")
	fd_ServiceEndpoints_endpoints = md_ServiceEndpoints.Fields().ByName("endpoints")
}

var _ protoreflect.Message = (*fastReflection_ServiceEndpoints)(nil)

type fastReflection_ServiceEndpoints ServiceEndpoints

func (x *ServiceEndpoints) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ServiceEndpoints)(x)
}

func (x *ServiceEndpoints) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ServiceEndpoints_messageType fastReflection_ServiceEndpoints_messageType
var _ protoreflect.MessageType = fastReflection_ServiceEndpoints_messageType{}

type fastReflection_ServiceEndpoints_messageType struct{}

func (x fastReflection_ServiceEndpoints_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ServiceEndpoints)(nil)
}
func (x fastReflection_ServiceEndpoints_messageType) New() protoreflect.Message {
	return new(fastReflection_ServiceEndpoints)
}
func (x fastReflection_ServiceEndpoints_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ServiceEndpoints
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ServiceEndpoints) Descriptor() protoreflect.MessageDescriptor {
	return md_ServiceEndpoints
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ServiceEndpoints) Type() protoreflect.MessageType {
	return _fastReflection_ServiceEndpoints_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ServiceEndpoints) New() protoreflect.Message {
	return new(fastReflection_ServiceEndpoints)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ServiceEndpoints) Interface() protoreflect.ProtoMessage {
	return (*ServiceEndpoints)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ServiceEndpoints) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Endpoints) != 0 {
		value := protoreflect.ValueOfList(&_ServiceEndpoints_1_list{list: &x.Endpoints})
		if !f(fd_ServiceEndpoints_endpoints, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ServiceEndpoints) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.ServiceEndpoints.endpoints":
		return len(x.Endpoints) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.ServiceEndpoints"))
		}
		panic(fmt.Errorf("message did.v1.ServiceEndpoints does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ServiceEndpoints) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.ServiceEndpoints.endpoints":
		x.Endpoints = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.ServiceEndpoints"))
		}
		panic(fmt.Errorf("message did.v1.ServiceEndpoints does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ServiceEndpoints) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.ServiceEndpoints.endpoints":
		if len(x.Endpoints) == 0 {
			return protoreflect.ValueOfList(&_ServiceEndpoints_1_list{})
		}
		listValue := &_ServiceEndpoints_1_list{list: &x.Endpoints}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.ServiceEndpoints"))
		}
		panic(fmt.Errorf("message did.v1.ServiceEndpoints does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ServiceEndpoints) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.ServiceEndpoints.endpoints":
		lv := value.List()
		clv := lv.(*_ServiceEndpoints_1_list)
		x.Endpoints = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.ServiceEndpoints"))
		}
		panic(fmt.Errorf("message did.v1.ServiceEndpoints does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ServiceEndpoints) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.ServiceEndpoints.endpoints":
		if x.Endpoints == nil {
			x.Endpoints = []string{}
		}
		value := &_ServiceEndpoints_1_list{list: &x.Endpoints}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.ServiceEndpoints"))
		}
		panic(fmt.Errorf("message did.v1.ServiceEndpoints does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ServiceEndpoints) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.ServiceEndpoints.endpoints":
		list := []string{}
		return protoreflect.ValueOfList(&_ServiceEndpoints_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.ServiceEndpoints"))
		}
		panic(fmt.Errorf("message did.v1.ServiceEndpoints does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ServiceEndpoints) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.ServiceEndpoints", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ServiceEndpoints) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ServiceEndpoints) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ServiceEndpoints) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ServiceEndpoints) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ServiceEndpoints)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Endpoints) > 0 {
			for _, s := range x.Endpoints {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ServiceEndpoints)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Endpoints) > 0 {
			for iNdEx := len(x.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Endpoints[iNdEx])
				copy(dAtA[i:], x.Endpoints[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Endpoints[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ServiceEndpoints)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ServiceEndpoints: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ServiceEndpoints: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Endpoints = append(x.Endpoints, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_WebAuthnCredential_9_list)(nil)

type _WebAuthnCredential_9_list struct {
	list *[]string
}

func (x *_WebAuthnCredential_9_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_WebAuthnCredential_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_WebAuthnCredential_9_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_WebAuthnCredential_9_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_WebAuthnCredential_9_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message WebAuthnCredential at list field Transports as it is not of Message kind"))
}

func (x *_WebAuthnCredential_9_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_WebAuthnCredential_9_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_WebAuthnCredential_9_list) IsValid() bool {
	return x.list != nil
}

var (
	md_WebAuthnCredential                     protoreflect.MessageDescriptor
	fd_WebAuthnCredential_credential_id       protoreflect.FieldDescriptor
	fd_WebAuthnCredential_public_key          protoreflect.FieldDescriptor
	fd_WebAuthnCredential_algorithm           protoreflect.FieldDescriptor
	fd_WebAuthnCredential_attestation_type    protoreflect.FieldDescriptor
	fd_WebAuthnCredential_origin              protoreflect.FieldDescriptor
	fd_WebAuthnCredential_created_at          protoreflect.FieldDescriptor
	fd_WebAuthnCredential_rp_id               protoreflect.FieldDescriptor
	fd_WebAuthnCredential_rp_name             protoreflect.FieldDescriptor
	fd_WebAuthnCredential_transports          protoreflect.FieldDescriptor
	fd_WebAuthnCredential_user_verified       protoreflect.FieldDescriptor
	fd_WebAuthnCredential_signature_algorithm protoreflect.FieldDescriptor
	fd_WebAuthnCredential_raw_id              protoreflect.FieldDescriptor
	fd_WebAuthnCredential_client_data_json    protoreflect.FieldDescriptor
	fd_WebAuthnCredential_attestation_object  protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_WebAuthnCredential = File_did_v1_types_proto.Messages().ByName("WebAuthnCredential")
	fd_WebAuthnCredential_credential_id = md_WebAuthnCredential.Fields().ByName("credential_id")
	fd_WebAuthnCredential_public_key = md_WebAuthnCredential.Fields().ByName("public_key")
	fd_WebAuthnCredential_algorithm = md_WebAuthnCredential.Fields().ByName("algorithm")
	fd_WebAuthnCredential_attestation_type = md_WebAuthnCredential.Fields().ByName("attestation_type")
	fd_WebAuthnCredential_origin = md_WebAuthnCredential.Fields().ByName("origin")
	fd_WebAuthnCredential_created_at = md_WebAuthnCredential.Fields().ByName("created_at")
	fd_WebAuthnCredential_rp_id = md_WebAuthnCredential.Fields().ByName("rp_id")
	fd_WebAuthnCredential_rp_name = md_WebAuthnCredential.Fields().ByName("rp_name")
	fd_WebAuthnCredential_transports = md_WebAuthnCredential.Fields().ByName("transports")
	fd_WebAuthnCredential_user_verified = md_WebAuthnCredential.Fields().ByName("user_verified")
	fd_WebAuthnCredential_signature_algorithm = md_WebAuthnCredential.Fields().ByName("signature_algorithm")
	fd_WebAuthnCredential_raw_id = md_WebAuthnCredential.Fields().ByName("raw_id")
	fd_WebAuthnCredential_client_data_json = md_WebAuthnCredential.Fields().ByName("client_data_json")
	fd_WebAuthnCredential_attestation_object = md_WebAuthnCredential.Fields().ByName("attestation_object")
}

var _ protoreflect.Message = (*fastReflection_WebAuthnCredential)(nil)

type fastReflection_WebAuthnCredential WebAuthnCredential

func (x *WebAuthnCredential) ProtoReflect() protoreflect.Message {
	return (*fastReflection_WebAuthnCredential)(x)
}

func (x *WebAuthnCredential) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_WebAuthnCredential_messageType fastReflection_WebAuthnCredential_messageType
var _ protoreflect.MessageType = fastReflection_WebAuthnCredential_messageType{}

type fastReflection_WebAuthnCredential_messageType struct{}

func (x fastReflection_WebAuthnCredential_messageType) Zero() protoreflect.Message {
	return (*fastReflection_WebAuthnCredential)(nil)
}
func (x fastReflection_WebAuthnCredential_messageType) New() protoreflect.Message {
	return new(fastReflection_WebAuthnCredential)
}
func (x fastReflection_WebAuthnCredential_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_WebAuthnCredential
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_WebAuthnCredential) Descriptor() protoreflect.MessageDescriptor {
	return md_WebAuthnCredential
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_WebAuthnCredential) Type() protoreflect.MessageType {
	return _fastReflection_WebAuthnCredential_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_WebAuthnCredential) New() protoreflect.Message {
	return new(fastReflection_WebAuthnCredential)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_WebAuthnCredential) Interface() protoreflect.ProtoMessage {
	return (*WebAuthnCredential)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_WebAuthnCredential) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.CredentialId != "" {
		value := protoreflect.ValueOfString(x.CredentialId)
		if !f(fd_WebAuthnCredential_credential_id, value) {
			return
		}
	}
	if len(x.PublicKey) != 0 {
		value := protoreflect.ValueOfBytes(x.PublicKey)
		if !f(fd_WebAuthnCredential_public_key, value) {
			return
		}
	}
	if x.Algorithm != int32(0) {
		value := protoreflect.ValueOfInt32(x.Algorithm)
		if !f(fd_WebAuthnCredential_algorithm, value) {
			return
		}
	}
	if x.AttestationType != "" {
		value := protoreflect.ValueOfString(x.AttestationType)
		if !f(fd_WebAuthnCredential_attestation_type, value) {
			return
		}
	}
	if x.Origin != "" {
		value := protoreflect.ValueOfString(x.Origin)
		if !f(fd_WebAuthnCredential_origin, value) {
			return
		}
	}
	if x.CreatedAt != int64(0) {
		value := protoreflect.ValueOfInt64(x.CreatedAt)
		if !f(fd_WebAuthnCredential_created_at, value) {
			return
		}
	}
	if x.RpId != "" {
		value := protoreflect.ValueOfString(x.RpId)
		if !f(fd_WebAuthnCredential_rp_id, value) {
			return
		}
	}
	if x.RpName != "" {
		value := protoreflect.ValueOfString(x.RpName)
		if !f(fd_WebAuthnCredential_rp_name, value) {
			return
		}
	}
	if len(x.Transports) != 0 {
		value := protoreflect.ValueOfList(&_WebAuthnCredential_9_list{list: &x.Transports})
		if !f(fd_WebAuthnCredential_transports, value) {
			return
		}
	}
	if x.UserVerified != false {
		value := protoreflect.ValueOfBool(x.UserVerified)
		if !f(fd_WebAuthnCredential_user_verified, value) {
			return
		}
	}
	if x.SignatureAlgorithm != "" {
		value := protoreflect.ValueOfString(x.SignatureAlgorithm)
		if !f(fd_WebAuthnCredential_signature_algorithm, value) {
			return
		}
	}
	if x.RawId != "" {
		value := protoreflect.ValueOfString(x.RawId)
		if !f(fd_WebAuthnCredential_raw_id, value) {
			return
		}
	}
	if x.ClientDataJson != "" {
		value := protoreflect.ValueOfString(x.ClientDataJson)
		if !f(fd_WebAuthnCredential_client_data_json, value) {
			return
		}
	}
	if x.AttestationObject != "" {
		value := protoreflect.ValueOfString(x.AttestationObject)
		if !f(fd_WebAuthnCredential_attestation_object, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_WebAuthnCredential) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.WebAuthnCredential.credential_id":
		return x.CredentialId != ""
	case "did.v1.WebAuthnCredential.public_key":
		return len(x.PublicKey) != 0
	case "did.v1.WebAuthnCredential.algorithm":
		return x.Algorithm != int32(0)
	case "did.v1.WebAuthnCredential.attestation_type":
		return x.AttestationType != ""
	case "did.v1.WebAuthnCredential.origin":
		return x.Origin != ""
	case "did.v1.WebAuthnCredential.created_at":
		return x.CreatedAt != int64(0)
	case "did.v1.WebAuthnCredential.rp_id":
		return x.RpId != ""
	case "did.v1.WebAuthnCredential.rp_name":
		return x.RpName != ""
	case "did.v1.WebAuthnCredential.transports":
		return len(x.Transports) != 0
	case "did.v1.WebAuthnCredential.user_verified":
		return x.UserVerified != false
	case "did.v1.WebAuthnCredential.signature_algorithm":
		return x.SignatureAlgorithm != ""
	case "did.v1.WebAuthnCredential.raw_id":
		return x.RawId != ""
	case "did.v1.WebAuthnCredential.client_data_json":
		return x.ClientDataJson != ""
	case "did.v1.WebAuthnCredential.attestation_object":
		return x.AttestationObject != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.WebAuthnCredential"))
		}
		panic(fmt.Errorf("message did.v1.WebAuthnCredential does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WebAuthnCredential) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.WebAuthnCredential.credential_id":
		x.CredentialId = ""
	case "did.v1.WebAuthnCredential.public_key":
		x.PublicKey = nil
	case "did.v1.WebAuthnCredential.algorithm":
		x.Algorithm = int32(0)
	case "did.v1.WebAuthnCredential.attestation_type":
		x.AttestationType = ""
	case "did.v1.WebAuthnCredential.origin":
		x.Origin = ""
	case "did.v1.WebAuthnCredential.created_at":
		x.CreatedAt = int64(0)
	case "did.v1.WebAuthnCredential.rp_id":
		x.RpId = ""
	case "did.v1.WebAuthnCredential.rp_name":
		x.RpName = ""
	case "did.v1.WebAuthnCredential.transports":
		x.Transports = nil
	case "did.v1.WebAuthnCredential.user_verified":
		x.UserVerified = false
	case "did.v1.WebAuthnCredential.signature_algorithm":
		x.SignatureAlgorithm = ""
	case "did.v1.WebAuthnCredential.raw_id":
		x.RawId = ""
	case "did.v1.WebAuthnCredential.client_data_json":
		x.ClientDataJson = ""
	case "did.v1.WebAuthnCredential.attestation_object":
		x.AttestationObject = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.WebAuthnCredential"))
		}
		panic(fmt.Errorf("message did.v1.WebAuthnCredential does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_WebAuthnCredential) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.WebAuthnCredential.credential_id":
		value := x.CredentialId
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.public_key":
		value := x.PublicKey
		return protoreflect.ValueOfBytes(value)
	case "did.v1.WebAuthnCredential.algorithm":
		value := x.Algorithm
		return protoreflect.ValueOfInt32(value)
	case "did.v1.WebAuthnCredential.attestation_type":
		value := x.AttestationType
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.origin":
		value := x.Origin
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.created_at":
		value := x.CreatedAt
		return protoreflect.ValueOfInt64(value)
	case "did.v1.WebAuthnCredential.rp_id":
		value := x.RpId
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.rp_name":
		value := x.RpName
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.transports":
		if len(x.Transports) == 0 {
			return protoreflect.ValueOfList(&_WebAuthnCredential_9_list{})
		}
		listValue := &_WebAuthnCredential_9_list{list: &x.Transports}
		return protoreflect.ValueOfList(listValue)
	case "did.v1.WebAuthnCredential.user_verified":
		value := x.UserVerified
		return protoreflect.ValueOfBool(value)
	case "did.v1.WebAuthnCredential.signature_algorithm":
		value := x.SignatureAlgorithm
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.raw_id":
		value := x.RawId
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.client_data_json":
		value := x.ClientDataJson
		return protoreflect.ValueOfString(value)
	case "did.v1.WebAuthnCredential.attestation_object":
		value := x.AttestationObject
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.WebAuthnCredential"))
		}
		panic(fmt.Errorf("message did.v1.WebAuthnCredential does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WebAuthnCredential) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.WebAuthnCredential.credential_id":
		x.CredentialId = value.Interface().(string)
	case "did.v1.WebAuthnCredential.public_key":
		x.PublicKey = value.Bytes()
	case "did.v1.WebAuthnCredential.algorithm":
		x.Algorithm = int32(value.Int())
	case "did.v1.WebAuthnCredential.attestation_type":
		x.AttestationType = value.Interface().(string)
	case "did.v1.WebAuthnCredential.origin":
		x.Origin = value.Interface().(string)
	case "did.v1.WebAuthnCredential.created_at":
		x.CreatedAt = value.Int()
	case "did.v1.WebAuthnCredential.rp_id":
		x.RpId = value.Interface().(string)
	case "did.v1.WebAuthnCredential.rp_name":
		x.RpName = value.Interface().(string)
	case "did.v1.WebAuthnCredential.transports":
		lv := value.List()
		clv := lv.(*_WebAuthnCredential_9_list)
		x.Transports = *clv.list
	case "did.v1.WebAuthnCredential.user_verified":
		x.UserVerified = value.Bool()
	case "did.v1.WebAuthnCredential.signature_algorithm":
		x.SignatureAlgorithm = value.Interface().(string)
	case "did.v1.WebAuthnCredential.raw_id":
		x.RawId = value.Interface().(string)
	case "did.v1.WebAuthnCredential.client_data_json":
		x.ClientDataJson = value.Interface().(string)
	case "did.v1.WebAuthnCredential.attestation_object":
		x.AttestationObject = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.WebAuthnCredential"))
		}
		panic(fmt.Errorf("message did.v1.WebAuthnCredential does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WebAuthnCredential) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.WebAuthnCredential.transports":
		if x.Transports == nil {
			x.Transports = []string{}
		}
		value := &_WebAuthnCredential_9_list{list: &x.Transports}
		return protoreflect.ValueOfList(value)
	case "did.v1.WebAuthnCredential.credential_id":
		panic(fmt.Errorf("field credential_id of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.public_key":
		panic(fmt.Errorf("field public_key of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.algorithm":
		panic(fmt.Errorf("field algorithm of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.attestation_type":
		panic(fmt.Errorf("field attestation_type of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.origin":
		panic(fmt.Errorf("field origin of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.created_at":
		panic(fmt.Errorf("field created_at of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.rp_id":
		panic(fmt.Errorf("field rp_id of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.rp_name":
		panic(fmt.Errorf("field rp_name of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.user_verified":
		panic(fmt.Errorf("field user_verified of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.signature_algorithm":
		panic(fmt.Errorf("field signature_algorithm of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.raw_id":
		panic(fmt.Errorf("field raw_id of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.client_data_json":
		panic(fmt.Errorf("field client_data_json of message did.v1.WebAuthnCredential is not mutable"))
	case "did.v1.WebAuthnCredential.attestation_object":
		panic(fmt.Errorf("field attestation_object of message did.v1.WebAuthnCredential is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.WebAuthnCredential"))
		}
		panic(fmt.Errorf("message did.v1.WebAuthnCredential does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_WebAuthnCredential) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.WebAuthnCredential.credential_id":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.public_key":
		return protoreflect.ValueOfBytes(nil)
	case "did.v1.WebAuthnCredential.algorithm":
		return protoreflect.ValueOfInt32(int32(0))
	case "did.v1.WebAuthnCredential.attestation_type":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.origin":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.created_at":
		return protoreflect.ValueOfInt64(int64(0))
	case "did.v1.WebAuthnCredential.rp_id":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.rp_name":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.transports":
		list := []string{}
		return protoreflect.ValueOfList(&_WebAuthnCredential_9_list{list: &list})
	case "did.v1.WebAuthnCredential.user_verified":
		return protoreflect.ValueOfBool(false)
	case "did.v1.WebAuthnCredential.signature_algorithm":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.raw_id":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.client_data_json":
		return protoreflect.ValueOfString("")
	case "did.v1.WebAuthnCredential.attestation_object":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.WebAuthnCredential"))
		}
		panic(fmt.Errorf("message did.v1.WebAuthnCredential does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_WebAuthnCredential) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.WebAuthnCredential", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_WebAuthnCredential) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WebAuthnCredential) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_WebAuthnCredential) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_WebAuthnCredential) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*WebAuthnCredential)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.CredentialId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PublicKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Algorithm != 0 {
			n += 1 + runtime.Sov(uint64(x.Algorithm))
		}
		l = len(x.AttestationType)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Origin)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CreatedAt != 0 {
			n += 1 + runtime.Sov(uint64(x.CreatedAt))
		}
		l = len(x.RpId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RpName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Transports) > 0 {
			for _, s := range x.Transports {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.UserVerified {
			n += 2
		}
		l = len(x.SignatureAlgorithm)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RawId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ClientDataJson)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AttestationObject)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*WebAuthnCredential)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AttestationObject) > 0 {
			i -= len(x.AttestationObject)
			copy(dAtA[i:], x.AttestationObject)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AttestationObject)))
			i--
			dAtA[i] = 0x72
		}
		if len(x.ClientDataJson) > 0 {
			i -= len(x.ClientDataJson)
			copy(dAtA[i:], x.ClientDataJson)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ClientDataJson)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.RawId) > 0 {
			i -= len(x.RawId)
			copy(dAtA[i:], x.RawId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RawId)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.SignatureAlgorithm) > 0 {
			i -= len(x.SignatureAlgorithm)
			copy(dAtA[i:], x.SignatureAlgorithm)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SignatureAlgorithm)))
			i--
			dAtA[i] = 0x5a
		}
		if x.UserVerified {
			i--
			if x.UserVerified {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x50
		}
		if len(x.Transports) > 0 {
			for iNdEx := len(x.Transports) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Transports[iNdEx])
				copy(dAtA[i:], x.Transports[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Transports[iNdEx])))
				i--
				dAtA[i] = 0x4a
			}
		}
		if len(x.RpName) > 0 {
			i -= len(x.RpName)
			copy(dAtA[i:], x.RpName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RpName)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.RpId) > 0 {
			i -= len(x.RpId)
			copy(dAtA[i:], x.RpId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RpId)))
			i--
			dAtA[i] = 0x3a
		}
		if x.CreatedAt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CreatedAt))
			i--
			dAtA[i] = 0x30
		}
		if len(x.Origin) > 0 {
			i -= len(x.Origin)
			copy(dAtA[i:], x.Origin)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Origin)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.AttestationType) > 0 {
			i -= len(x.AttestationType)
			copy(dAtA[i:], x.AttestationType)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AttestationType)))
			i--
			dAtA[i] = 0x22
		}
		if x.Algorithm != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Algorithm))
			i--
			dAtA[i] = 0x18
		}
		if len(x.PublicKey) > 0 {
			i -= len(x.PublicKey)
			copy(dAtA[i:], x.PublicKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicKey)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.CredentialId) > 0 {
			i -= len(x.CredentialId)
			copy(dAtA[i:], x.CredentialId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CredentialId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*WebAuthnCredential)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: WebAuthnCredential: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: WebAuthnCredential: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CredentialId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicKey = append(x.PublicKey[:0], dAtA[iNdEx:postIndex]...)
				if x.PublicKey == nil {
					x.PublicKey = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
				}
				x.Algorithm = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Algorithm |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AttestationType = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Origin = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
				}
				x.CreatedAt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CreatedAt |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RpId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RpId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RpName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RpName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Transports", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Transports = append(x.Transports, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UserVerified", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UserVerified = bool(v != 0)
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgorithm", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SignatureAlgorithm = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RawId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RawId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ClientDataJson", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ClientDataJson = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AttestationObject", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AttestationObject = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.Map = (*_CredentialProof_6_map)(nil)

type _CredentialProof_6_map struct {
	m *map[string]string
}

func (x *_CredentialProof_6_map) Len() int {
	if x.m == nil {
		return 0
	}
	return len(*x.m)
}

func (x *_CredentialProof_6_map) Range(f func(protoreflect.MapKey, protoreflect.Value) bool) {
	if x.m == nil {
		return
	}
	for k, v := range *x.m {
		mapKey := (protoreflect.MapKey)(protoreflect.ValueOfString(k))
		mapValue := protoreflect.ValueOfString(v)
		if !f(mapKey, mapValue) {
			break
		}
	}
}

func (x *_CredentialProof_6_map) Has(key protoreflect.MapKey) bool {
	if x.m == nil {
		return false
	}
	keyUnwrapped := key.String()
	concreteValue := keyUnwrapped
	_, ok := (*x.m)[concreteValue]
	return ok
}

func (x *_CredentialProof_6_map) Clear(key protoreflect.MapKey) {
	if x.m == nil {
		return
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	delete(*x.m, concreteKey)
}

func (x *_CredentialProof_6_map) Get(key protoreflect.MapKey) protoreflect.Value {
	if x.m == nil {
		return protoreflect.Value{}
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	v, ok := (*x.m)[concreteKey]
	if !ok {
		return protoreflect.Value{}
	}
	return protoreflect.ValueOfString(v)
}

func (x *_CredentialProof_6_map) Set(key protoreflect.MapKey, value protoreflect.Value) {
	if !key.IsValid() || !value.IsValid() {
		panic("invalid key or value provided")
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.m)[concreteKey] = concreteValue
}

func (x *_CredentialProof_6_map) Mutable(key protoreflect.MapKey) protoreflect.Value {
	panic("should not call Mutable on protoreflect.Map whose value is not of type protoreflect.Message")
}

func (x *_CredentialProof_6_map) NewValue() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_CredentialProof_6_map) IsValid() bool {
	return x.m != nil
}

var (
	md_CredentialProof                     protoreflect.MessageDescriptor
	fd_CredentialProof_proof_kind          protoreflect.FieldDescriptor
	fd_CredentialProof_created             protoreflect.FieldDescriptor
	fd_CredentialProof_verification_method protoreflect.FieldDescriptor
	fd_CredentialProof_proof_purpose       protoreflect.FieldDescriptor
	fd_CredentialProof_signature           protoreflect.FieldDescriptor
	fd_CredentialProof_properties          protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_CredentialProof = File_did_v1_types_proto.Messages().ByName("CredentialProof")
	fd_CredentialProof_proof_kind = md_CredentialProof.Fields().ByName("proof_kind")
	fd_CredentialProof_created = md_CredentialProof.Fields().ByName("created")
	fd_CredentialProof_verification_method = md_CredentialProof.Fields().ByName("verification_method")
	fd_CredentialProof_proof_purpose = md_CredentialProof.Fields().ByName("proof_purpose")
	fd_CredentialProof_signature = md_CredentialProof.Fields().ByName("signature")
	fd_CredentialProof_properties = md_CredentialProof.Fields().ByName("properties")
}

var _ protoreflect.Message = (*fastReflection_CredentialProof)(nil)

type fastReflection_CredentialProof CredentialProof

func (x *CredentialProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CredentialProof)(x)
}

func (x *CredentialProof) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CredentialProof_messageType fastReflection_CredentialProof_messageType
var _ protoreflect.MessageType = fastReflection_CredentialProof_messageType{}

type fastReflection_CredentialProof_messageType struct{}

func (x fastReflection_CredentialProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CredentialProof)(nil)
}
func (x fastReflection_CredentialProof_messageType) New() protoreflect.Message {
	return new(fastReflection_CredentialProof)
}
func (x fastReflection_CredentialProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CredentialProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CredentialProof) Descriptor() protoreflect.MessageDescriptor {
	return md_CredentialProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CredentialProof) Type() protoreflect.MessageType {
	return _fastReflection_CredentialProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CredentialProof) New() protoreflect.Message {
	return new(fastReflection_CredentialProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CredentialProof) Interface() protoreflect.ProtoMessage {
	return (*CredentialProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CredentialProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ProofKind != "" {
		value := protoreflect.ValueOfString(x.ProofKind)
		if !f(fd_CredentialProof_proof_kind, value) {
			return
		}
	}
	if x.Created != "" {
		value := protoreflect.ValueOfString(x.Created)
		if !f(fd_CredentialProof_created, value) {
			return
		}
	}
	if x.VerificationMethod != "" {
		value := protoreflect.ValueOfString(x.VerificationMethod)
		if !f(fd_CredentialProof_verification_method, value) {
			return
		}
	}
	if x.ProofPurpose != "" {
		value := protoreflect.ValueOfString(x.ProofPurpose)
		if !f(fd_CredentialProof_proof_purpose, value) {
			return
		}
	}
	if x.Signature != "" {
		value := protoreflect.ValueOfString(x.Signature)
		if !f(fd_CredentialProof_signature, value) {
			return
		}
	}
	if len(x.Properties) != 0 {
		value := protoreflect.ValueOfMap(&_CredentialProof_6_map{m: &x.Properties})
		if !f(fd_CredentialProof_properties, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CredentialProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.CredentialProof.proof_kind":
		return x.ProofKind != ""
	case "did.v1.CredentialProof.created":
		return x.Created != ""
	case "did.v1.CredentialProof.verification_method":
		return x.VerificationMethod != ""
	case "did.v1.CredentialProof.proof_purpose":
		return x.ProofPurpose != ""
	case "did.v1.CredentialProof.signature":
		return x.Signature != ""
	case "did.v1.CredentialProof.properties":
		return len(x.Properties) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialProof"))
		}
		panic(fmt.Errorf("message did.v1.CredentialProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.CredentialProof.proof_kind":
		x.ProofKind = ""
	case "did.v1.CredentialProof.created":
		x.Created = ""
	case "did.v1.CredentialProof.verification_method":
		x.VerificationMethod = ""
	case "did.v1.CredentialProof.proof_purpose":
		x.ProofPurpose = ""
	case "did.v1.CredentialProof.signature":
		x.Signature = ""
	case "did.v1.CredentialProof.properties":
		x.Properties = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialProof"))
		}
		panic(fmt.Errorf("message did.v1.CredentialProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CredentialProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.CredentialProof.proof_kind":
		value := x.ProofKind
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialProof.created":
		value := x.Created
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialProof.verification_method":
		value := x.VerificationMethod
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialProof.proof_purpose":
		value := x.ProofPurpose
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialProof.signature":
		value := x.Signature
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialProof.properties":
		if len(x.Properties) == 0 {
			return protoreflect.ValueOfMap(&_CredentialProof_6_map{})
		}
		mapValue := &_CredentialProof_6_map{m: &x.Properties}
		return protoreflect.ValueOfMap(mapValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialProof"))
		}
		panic(fmt.Errorf("message did.v1.CredentialProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.CredentialProof.proof_kind":
		x.ProofKind = value.Interface().(string)
	case "did.v1.CredentialProof.created":
		x.Created = value.Interface().(string)
	case "did.v1.CredentialProof.verification_method":
		x.VerificationMethod = value.Interface().(string)
	case "did.v1.CredentialProof.proof_purpose":
		x.ProofPurpose = value.Interface().(string)
	case "did.v1.CredentialProof.signature":
		x.Signature = value.Interface().(string)
	case "did.v1.CredentialProof.properties":
		mv := value.Map()
		cmv := mv.(*_CredentialProof_6_map)
		x.Properties = *cmv.m
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialProof"))
		}
		panic(fmt.Errorf("message did.v1.CredentialProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.CredentialProof.properties":
		if x.Properties == nil {
			x.Properties = make(map[string]string)
		}
		value := &_CredentialProof_6_map{m: &x.Properties}
		return protoreflect.ValueOfMap(value)
	case "did.v1.CredentialProof.proof_kind":
		panic(fmt.Errorf("field proof_kind of message did.v1.CredentialProof is not mutable"))
	case "did.v1.CredentialProof.created":
		panic(fmt.Errorf("field created of message did.v1.CredentialProof is not mutable"))
	case "did.v1.CredentialProof.verification_method":
		panic(fmt.Errorf("field verification_method of message did.v1.CredentialProof is not mutable"))
	case "did.v1.CredentialProof.proof_purpose":
		panic(fmt.Errorf("field proof_purpose of message did.v1.CredentialProof is not mutable"))
	case "did.v1.CredentialProof.signature":
		panic(fmt.Errorf("field signature of message did.v1.CredentialProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialProof"))
		}
		panic(fmt.Errorf("message did.v1.CredentialProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CredentialProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.CredentialProof.proof_kind":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialProof.created":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialProof.verification_method":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialProof.proof_purpose":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialProof.signature":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialProof.properties":
		m := make(map[string]string)
		return protoreflect.ValueOfMap(&_CredentialProof_6_map{m: &m})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialProof"))
		}
		panic(fmt.Errorf("message did.v1.CredentialProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CredentialProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.CredentialProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CredentialProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CredentialProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CredentialProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CredentialProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ProofKind)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Created)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.VerificationMethod)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ProofPurpose)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Signature)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Properties) > 0 {
			SiZeMaP := func(k string, v string) {
				mapEntrySize := 1 + len(k) + runtime.Sov(uint64(len(k))) + 1 + len(v) + runtime.Sov(uint64(len(v)))
				n += mapEntrySize + 1 + runtime.Sov(uint64(mapEntrySize))
			}
			if options.Deterministic {
				sortme := make([]string, 0, len(x.Properties))
				for k := range x.Properties {
					sortme = append(sortme, k)
				}
				sort.Strings(sortme)
				for _, k := range sortme {
					v := x.Properties[k]
					SiZeMaP(k, v)
				}
			} else {
				for k, v := range x.Properties {
					SiZeMaP(k, v)
				}
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CredentialProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Properties) > 0 {
			MaRsHaLmAp := func(k string, v string) (protoiface.MarshalOutput, error) {
				baseI := i
				i -= len(v)
				copy(dAtA[i:], v)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
				i -= len(k)
				copy(dAtA[i:], k)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(k)))
				i--
				dAtA[i] = 0xa
				i = runtime.EncodeVarint(dAtA, i, uint64(baseI-i))
				i--
				dAtA[i] = 0x32
				return protoiface.MarshalOutput{}, nil
			}
			if options.Deterministic {
				keysForProperties := make([]string, 0, len(x.Properties))
				for k := range x.Properties {
					keysForProperties = append(keysForProperties, string(k))
				}
				sort.Slice(keysForProperties, func(i, j int) bool {
					return keysForProperties[i] < keysForProperties[j]
				})
				for iNdEx := len(keysForProperties) - 1; iNdEx >= 0; iNdEx-- {
					v := x.Properties[string(keysForProperties[iNdEx])]
					out, err := MaRsHaLmAp(keysForProperties[iNdEx], v)
					if err != nil {
						return out, err
					}
				}
			} else {
				for k := range x.Properties {
					v := x.Properties[k]
					out, err := MaRsHaLmAp(k, v)
					if err != nil {
						return out, err
					}
				}
			}
		}
		if len(x.Signature) > 0 {
			i -= len(x.Signature)
			copy(dAtA[i:], x.Signature)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Signature)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ProofPurpose) > 0 {
			i -= len(x.ProofPurpose)
			copy(dAtA[i:], x.ProofPurpose)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ProofPurpose)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.VerificationMethod) > 0 {
			i -= len(x.VerificationMethod)
			copy(dAtA[i:], x.VerificationMethod)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VerificationMethod)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Created) > 0 {
			i -= len(x.Created)
			copy(dAtA[i:], x.Created)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Created)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ProofKind) > 0 {
			i -= len(x.ProofKind)
			copy(dAtA[i:], x.ProofKind)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ProofKind)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CredentialProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CredentialProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CredentialProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProofKind", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ProofKind = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Created = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VerificationMethod", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VerificationMethod = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProofPurpose", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ProofPurpose = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Signature = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Properties == nil {
					x.Properties = make(map[string]string)
				}
				var mapkey string
				var mapvalue string
				for iNdEx < postIndex {
					entryPreIndex := iNdEx
					var wire uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						wire |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					fieldNum := int32(wire >> 3)
					if fieldNum == 1 {
						var stringLenmapkey uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapkey |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapkey := int(stringLenmapkey)
						if intStringLenmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapkey := iNdEx + intStringLenmapkey
						if postStringIndexmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapkey > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
						iNdEx = postStringIndexmapkey
					} else if fieldNum == 2 {
						var stringLenmapvalue uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapvalue |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapvalue := int(stringLenmapvalue)
						if intStringLenmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapvalue := iNdEx + intStringLenmapvalue
						if postStringIndexmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapvalue > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
						iNdEx = postStringIndexmapvalue
					} else {
						iNdEx = entryPreIndex
						skippy, err := runtime.Skip(dAtA[iNdEx:])
						if err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						if (skippy < 0) || (iNdEx+skippy) < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if (iNdEx + skippy) > postIndex {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						iNdEx += skippy
					}
				}
				x.Properties[mapkey] = mapvalue
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.Map = (*_CredentialStatus_3_map)(nil)

type _CredentialStatus_3_map struct {
	m *map[string]string
}

func (x *_CredentialStatus_3_map) Len() int {
	if x.m == nil {
		return 0
	}
	return len(*x.m)
}

func (x *_CredentialStatus_3_map) Range(f func(protoreflect.MapKey, protoreflect.Value) bool) {
	if x.m == nil {
		return
	}
	for k, v := range *x.m {
		mapKey := (protoreflect.MapKey)(protoreflect.ValueOfString(k))
		mapValue := protoreflect.ValueOfString(v)
		if !f(mapKey, mapValue) {
			break
		}
	}
}

func (x *_CredentialStatus_3_map) Has(key protoreflect.MapKey) bool {
	if x.m == nil {
		return false
	}
	keyUnwrapped := key.String()
	concreteValue := keyUnwrapped
	_, ok := (*x.m)[concreteValue]
	return ok
}

func (x *_CredentialStatus_3_map) Clear(key protoreflect.MapKey) {
	if x.m == nil {
		return
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	delete(*x.m, concreteKey)
}

func (x *_CredentialStatus_3_map) Get(key protoreflect.MapKey) protoreflect.Value {
	if x.m == nil {
		return protoreflect.Value{}
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	v, ok := (*x.m)[concreteKey]
	if !ok {
		return protoreflect.Value{}
	}
	return protoreflect.ValueOfString(v)
}

func (x *_CredentialStatus_3_map) Set(key protoreflect.MapKey, value protoreflect.Value) {
	if !key.IsValid() || !value.IsValid() {
		panic("invalid key or value provided")
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.m)[concreteKey] = concreteValue
}

func (x *_CredentialStatus_3_map) Mutable(key protoreflect.MapKey) protoreflect.Value {
	panic("should not call Mutable on protoreflect.Map whose value is not of type protoreflect.Message")
}

func (x *_CredentialStatus_3_map) NewValue() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_CredentialStatus_3_map) IsValid() bool {
	return x.m != nil
}

var (
	md_CredentialStatus             protoreflect.MessageDescriptor
	fd_CredentialStatus_id          protoreflect.FieldDescriptor
	fd_CredentialStatus_status_kind protoreflect.FieldDescriptor
	fd_CredentialStatus_properties  protoreflect.FieldDescriptor
)

func init() {
	file_did_v1_types_proto_init()
	md_CredentialStatus = File_did_v1_types_proto.Messages().ByName("CredentialStatus")
	fd_CredentialStatus_id = md_CredentialStatus.Fields().ByName("id")
	fd_CredentialStatus_status_kind = md_CredentialStatus.Fields().ByName("status_kind")
	fd_CredentialStatus_properties = md_CredentialStatus.Fields().ByName("properties")
}

var _ protoreflect.Message = (*fastReflection_CredentialStatus)(nil)

type fastReflection_CredentialStatus CredentialStatus

func (x *CredentialStatus) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CredentialStatus)(x)
}

func (x *CredentialStatus) slowProtoReflect() protoreflect.Message {
	mi := &file_did_v1_types_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CredentialStatus_messageType fastReflection_CredentialStatus_messageType
var _ protoreflect.MessageType = fastReflection_CredentialStatus_messageType{}

type fastReflection_CredentialStatus_messageType struct{}

func (x fastReflection_CredentialStatus_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CredentialStatus)(nil)
}
func (x fastReflection_CredentialStatus_messageType) New() protoreflect.Message {
	return new(fastReflection_CredentialStatus)
}
func (x fastReflection_CredentialStatus_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CredentialStatus
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CredentialStatus) Descriptor() protoreflect.MessageDescriptor {
	return md_CredentialStatus
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CredentialStatus) Type() protoreflect.MessageType {
	return _fastReflection_CredentialStatus_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CredentialStatus) New() protoreflect.Message {
	return new(fastReflection_CredentialStatus)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CredentialStatus) Interface() protoreflect.ProtoMessage {
	return (*CredentialStatus)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CredentialStatus) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != "" {
		value := protoreflect.ValueOfString(x.Id)
		if !f(fd_CredentialStatus_id, value) {
			return
		}
	}
	if x.StatusKind != "" {
		value := protoreflect.ValueOfString(x.StatusKind)
		if !f(fd_CredentialStatus_status_kind, value) {
			return
		}
	}
	if len(x.Properties) != 0 {
		value := protoreflect.ValueOfMap(&_CredentialStatus_3_map{m: &x.Properties})
		if !f(fd_CredentialStatus_properties, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CredentialStatus) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "did.v1.CredentialStatus.id":
		return x.Id != ""
	case "did.v1.CredentialStatus.status_kind":
		return x.StatusKind != ""
	case "did.v1.CredentialStatus.properties":
		return len(x.Properties) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialStatus"))
		}
		panic(fmt.Errorf("message did.v1.CredentialStatus does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialStatus) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "did.v1.CredentialStatus.id":
		x.Id = ""
	case "did.v1.CredentialStatus.status_kind":
		x.StatusKind = ""
	case "did.v1.CredentialStatus.properties":
		x.Properties = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialStatus"))
		}
		panic(fmt.Errorf("message did.v1.CredentialStatus does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CredentialStatus) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "did.v1.CredentialStatus.id":
		value := x.Id
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialStatus.status_kind":
		value := x.StatusKind
		return protoreflect.ValueOfString(value)
	case "did.v1.CredentialStatus.properties":
		if len(x.Properties) == 0 {
			return protoreflect.ValueOfMap(&_CredentialStatus_3_map{})
		}
		mapValue := &_CredentialStatus_3_map{m: &x.Properties}
		return protoreflect.ValueOfMap(mapValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialStatus"))
		}
		panic(fmt.Errorf("message did.v1.CredentialStatus does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialStatus) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "did.v1.CredentialStatus.id":
		x.Id = value.Interface().(string)
	case "did.v1.CredentialStatus.status_kind":
		x.StatusKind = value.Interface().(string)
	case "did.v1.CredentialStatus.properties":
		mv := value.Map()
		cmv := mv.(*_CredentialStatus_3_map)
		x.Properties = *cmv.m
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialStatus"))
		}
		panic(fmt.Errorf("message did.v1.CredentialStatus does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialStatus) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.CredentialStatus.properties":
		if x.Properties == nil {
			x.Properties = make(map[string]string)
		}
		value := &_CredentialStatus_3_map{m: &x.Properties}
		return protoreflect.ValueOfMap(value)
	case "did.v1.CredentialStatus.id":
		panic(fmt.Errorf("field id of message did.v1.CredentialStatus is not mutable"))
	case "did.v1.CredentialStatus.status_kind":
		panic(fmt.Errorf("field status_kind of message did.v1.CredentialStatus is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialStatus"))
		}
		panic(fmt.Errorf("message did.v1.CredentialStatus does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CredentialStatus) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "did.v1.CredentialStatus.id":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialStatus.status_kind":
		return protoreflect.ValueOfString("")
	case "did.v1.CredentialStatus.properties":
		m := make(map[string]string)
		return protoreflect.ValueOfMap(&_CredentialStatus_3_map{m: &m})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: did.v1.CredentialStatus"))
		}
		panic(fmt.Errorf("message did.v1.CredentialStatus does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CredentialStatus) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in did.v1.CredentialStatus", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CredentialStatus) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CredentialStatus) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CredentialStatus) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CredentialStatus) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CredentialStatus)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Id)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StatusKind)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Properties) > 0 {
			SiZeMaP := func(k string, v string) {
				mapEntrySize := 1 + len(k) + runtime.Sov(uint64(len(k))) + 1 + len(v) + runtime.Sov(uint64(len(v)))
				n += mapEntrySize + 1 + runtime.Sov(uint64(mapEntrySize))
			}
			if options.Deterministic {
				sortme := make([]string, 0, len(x.Properties))
				for k := range x.Properties {
					sortme = append(sortme, k)
				}
				sort.Strings(sortme)
				for _, k := range sortme {
					v := x.Properties[k]
					SiZeMaP(k, v)
				}
			} else {
				for k, v := range x.Properties {
					SiZeMaP(k, v)
				}
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CredentialStatus)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Properties) > 0 {
			MaRsHaLmAp := func(k string, v string) (protoiface.MarshalOutput, error) {
				baseI := i
				i -= len(v)
				copy(dAtA[i:], v)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
				i -= len(k)
				copy(dAtA[i:], k)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(k)))
				i--
				dAtA[i] = 0xa
				i = runtime.EncodeVarint(dAtA, i, uint64(baseI-i))
				i--
				dAtA[i] = 0x1a
				return protoiface.MarshalOutput{}, nil
			}
			if options.Deterministic {
				keysForProperties := make([]string, 0, len(x.Properties))
				for k := range x.Properties {
					keysForProperties = append(keysForProperties, string(k))
				}
				sort.Slice(keysForProperties, func(i, j int) bool {
					return keysForProperties[i] < keysForProperties[j]
				})
				for iNdEx := len(keysForProperties) - 1; iNdEx >= 0; iNdEx-- {
					v := x.Properties[string(keysForProperties[iNdEx])]
					out, err := MaRsHaLmAp(keysForProperties[iNdEx], v)
					if err != nil {
						return out, err
					}
				}
			} else {
				for k := range x.Properties {
					v := x.Properties[k]
					out, err := MaRsHaLmAp(k, v)
					if err != nil {
						return out, err
					}
				}
			}
		}
		if len(x.StatusKind) > 0 {
			i -= len(x.StatusKind)
			copy(dAtA[i:], x.StatusKind)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StatusKind)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Id) > 0 {
			i -= len(x.Id)
			copy(dAtA[i:], x.Id)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Id)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CredentialStatus)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CredentialStatus: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CredentialStatus: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Id = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StatusKind", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StatusKind = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Properties == nil {
					x.Properties = make(map[string]string)
				}
				var mapkey string
				var mapvalue string
				for iNdEx < postIndex {
					entryPreIndex := iNdEx
					var wire uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						wire |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					fieldNum := int32(wire >> 3)
					if fieldNum == 1 {
						var stringLenmapkey uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapkey |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapkey := int(stringLenmapkey)
						if intStringLenmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapkey := iNdEx + intStringLenmapkey
						if postStringIndexmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapkey > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
						iNdEx = postStringIndexmapkey
					} else if fieldNum == 2 {
						var stringLenmapvalue uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapvalue |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapvalue := int(stringLenmapvalue)
						if intStringLenmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapvalue := iNdEx + intStringLenmapvalue
						if postStringIndexmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapvalue > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
						iNdEx = postStringIndexmapvalue
					} else {
						iNdEx = entryPreIndex
						skippy, err := runtime.Skip(dAtA[iNdEx:])
						if err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						if (skippy < 0) || (iNdEx+skippy) < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if (iNdEx + skippy) > postIndex {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						iNdEx += skippy
					}
				}
				x.Properties[mapkey] = mapvalue
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: did/v1/types.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// VerificationMethod represents a verification method in a DID document
type VerificationMethod struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the verification method identifier (REQUIRED)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// verification_method_kind is the verification method type (REQUIRED)
	VerificationMethodKind string `protobuf:"bytes,2,opt,name=verification_method_kind,json=verificationMethodKind,proto3" json:"verification_method_kind,omitempty"`
	// controller is the DID that controls this verification method (REQUIRED)
	Controller string `protobuf:"bytes,3,opt,name=controller,proto3" json:"controller,omitempty"`
	// Public key material (optional, only one should be set)
	// publicKeyJwk represents the public key as a JSON Web Key
	PublicKeyJwk string `protobuf:"bytes,4,opt,name=public_key_jwk,json=publicKeyJwk,proto3" json:"public_key_jwk,omitempty"`
	// publicKeyMultibase represents the public key as multibase
	PublicKeyMultibase string `protobuf:"bytes,5,opt,name=public_key_multibase,json=publicKeyMultibase,proto3" json:"public_key_multibase,omitempty"`
	// publicKeyBase58 represents the public key in Base58 (legacy)
	PublicKeyBase58 string `protobuf:"bytes,6,opt,name=public_key_base58,json=publicKeyBase58,proto3" json:"public_key_base58,omitempty"`
	// publicKeyBase64 represents the public key in Base64 (legacy)
	PublicKeyBase64 string `protobuf:"bytes,7,opt,name=public_key_base64,json=publicKeyBase64,proto3" json:"public_key_base64,omitempty"`
	// publicKeyPem represents the public key in PEM format (legacy)
	PublicKeyPem string `protobuf:"bytes,8,opt,name=public_key_pem,json=publicKeyPem,proto3" json:"public_key_pem,omitempty"`
	// publicKeyHex represents the public key in hexadecimal (legacy)
	PublicKeyHex string `protobuf:"bytes,9,opt,name=public_key_hex,json=publicKeyHex,proto3" json:"public_key_hex,omitempty"`
	// WebAuthn credential information (for WebAuthn integration)
	WebauthnCredential *WebAuthnCredential `protobuf:"bytes,10,opt,name=webauthn_credential,json=webauthnCredential,proto3" json:"webauthn_credential,omitempty"`
	// blockchain_account_id for external wallet linking (CAIP-10 format)
	// Format: "eip155:1:0x89a932207c485f85226d86f7cd486a89a24fcc12" for Ethereum
	// Format: "cosmos:cosmoshub-4:cosmos1..." for Cosmos chains
	BlockchainAccountId string `protobuf:"bytes,11,opt,name=blockchain_account_id,json=blockchainAccountId,proto3" json:"blockchain_account_id,omitempty"`
}

func (x *VerificationMethod) Reset() {
	*x = VerificationMethod{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VerificationMethod) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerificationMethod) ProtoMessage() {}

// Deprecated: Use VerificationMethod.ProtoReflect.Descriptor instead.
func (*VerificationMethod) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{0}
}

func (x *VerificationMethod) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *VerificationMethod) GetVerificationMethodKind() string {
	if x != nil {
		return x.VerificationMethodKind
	}
	return ""
}

func (x *VerificationMethod) GetController() string {
	if x != nil {
		return x.Controller
	}
	return ""
}

func (x *VerificationMethod) GetPublicKeyJwk() string {
	if x != nil {
		return x.PublicKeyJwk
	}
	return ""
}

func (x *VerificationMethod) GetPublicKeyMultibase() string {
	if x != nil {
		return x.PublicKeyMultibase
	}
	return ""
}

func (x *VerificationMethod) GetPublicKeyBase58() string {
	if x != nil {
		return x.PublicKeyBase58
	}
	return ""
}

func (x *VerificationMethod) GetPublicKeyBase64() string {
	if x != nil {
		return x.PublicKeyBase64
	}
	return ""
}

func (x *VerificationMethod) GetPublicKeyPem() string {
	if x != nil {
		return x.PublicKeyPem
	}
	return ""
}

func (x *VerificationMethod) GetPublicKeyHex() string {
	if x != nil {
		return x.PublicKeyHex
	}
	return ""
}

func (x *VerificationMethod) GetWebauthnCredential() *WebAuthnCredential {
	if x != nil {
		return x.WebauthnCredential
	}
	return nil
}

func (x *VerificationMethod) GetBlockchainAccountId() string {
	if x != nil {
		return x.BlockchainAccountId
	}
	return ""
}

// VerificationMethodReference can be either an embedded verification method
// or a reference
type VerificationMethodReference struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// verification_method_id is a reference to a verification method by ID (optional)
	VerificationMethodId string `protobuf:"bytes,1,opt,name=verification_method_id,json=verificationMethodId,proto3" json:"verification_method_id,omitempty"`
	// embedded_verification_method is an embedded verification method (optional)
	EmbeddedVerificationMethod *VerificationMethod `protobuf:"bytes,2,opt,name=embedded_verification_method,json=embeddedVerificationMethod,proto3" json:"embedded_verification_method,omitempty"`
}

func (x *VerificationMethodReference) Reset() {
	*x = VerificationMethodReference{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VerificationMethodReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerificationMethodReference) ProtoMessage() {}

// Deprecated: Use VerificationMethodReference.ProtoReflect.Descriptor instead.
func (*VerificationMethodReference) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{1}
}

func (x *VerificationMethodReference) GetVerificationMethodId() string {
	if x != nil {
		return x.VerificationMethodId
	}
	return ""
}

func (x *VerificationMethodReference) GetEmbeddedVerificationMethod() *VerificationMethod {
	if x != nil {
		return x.EmbeddedVerificationMethod
	}
	return nil
}

// Service represents a service endpoint in a DID document
type Service struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the service identifier (REQUIRED)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// service_kind is the service type (REQUIRED)
	ServiceKind string `protobuf:"bytes,2,opt,name=service_kind,json=serviceKind,proto3" json:"service_kind,omitempty"`
	// single_endpoint for a single URL
	SingleEndpoint string `protobuf:"bytes,3,opt,name=single_endpoint,json=singleEndpoint,proto3" json:"single_endpoint,omitempty"`
	// multiple_endpoints for multiple URLs
	MultipleEndpoints *ServiceEndpoints `protobuf:"bytes,4,opt,name=multiple_endpoints,json=multipleEndpoints,proto3" json:"multiple_endpoints,omitempty"`
	// complex_endpoint for complex endpoint objects as JSON
	ComplexEndpoint []byte `protobuf:"bytes,5,opt,name=complex_endpoint,json=complexEndpoint,proto3" json:"complex_endpoint,omitempty"`
	// Additional properties for the service
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Service) Reset() {
	*x = Service{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Service) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Service) ProtoMessage() {}

// Deprecated: Use Service.ProtoReflect.Descriptor instead.
func (*Service) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{2}
}

func (x *Service) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Service) GetServiceKind() string {
	if x != nil {
		return x.ServiceKind
	}
	return ""
}

func (x *Service) GetSingleEndpoint() string {
	if x != nil {
		return x.SingleEndpoint
	}
	return ""
}

func (x *Service) GetMultipleEndpoints() *ServiceEndpoints {
	if x != nil {
		return x.MultipleEndpoints
	}
	return nil
}

func (x *Service) GetComplexEndpoint() []byte {
	if x != nil {
		return x.ComplexEndpoint
	}
	return nil
}

func (x *Service) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// ServiceEndpoints represents multiple service endpoints
type ServiceEndpoints struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Endpoints []string `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
}

func (x *ServiceEndpoints) Reset() {
	*x = ServiceEndpoints{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ServiceEndpoints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceEndpoints) ProtoMessage() {}

// Deprecated: Use ServiceEndpoints.ProtoReflect.Descriptor instead.
func (*ServiceEndpoints) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{3}
}

func (x *ServiceEndpoints) GetEndpoints() []string {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

// WebAuthnCredential represents WebAuthn credential information
type WebAuthnCredential struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// credential_id is the WebAuthn credential ID
	CredentialId string `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// public_key is the WebAuthn public key
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// algorithm is the signing algorithm
	Algorithm int32 `protobuf:"varint,3,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	// attestation_type is the attestation type
	AttestationType string `protobuf:"bytes,4,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty"`
	// origin is the origin where the credential was created
	Origin string `protobuf:"bytes,5,opt,name=origin,proto3" json:"origin,omitempty"`
	// created_at is when the credential was created
	CreatedAt int64 `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// rp_id is the Relying Party ID
	RpId string `protobuf:"bytes,7,opt,name=rp_id,json=rpId,proto3" json:"rp_id,omitempty"`
	// rp_name is the Relying Party Name
	RpName string `protobuf:"bytes,8,opt,name=rp_name,json=rpName,proto3" json:"rp_name,omitempty"`
	// transports are the authenticator transports
	Transports []string `protobuf:"bytes,9,rep,name=transports,proto3" json:"transports,omitempty"`
	// user_verified indicates whether user verification was performed
	UserVerified bool `protobuf:"varint,10,opt,name=user_verified,json=userVerified,proto3" json:"user_verified,omitempty"`
	// signature_algorithm provides detailed algorithm information
	SignatureAlgorithm string `protobuf:"bytes,11,opt,name=signature_algorithm,json=signatureAlgorithm,proto3" json:"signature_algorithm,omitempty"`
	// raw_id is the base64url encoded raw credential ID
	RawId string `protobuf:"bytes,12,opt,name=raw_id,json=rawId,proto3" json:"raw_id,omitempty"`
	// client_data_json is the base64url encoded client data JSON
	ClientDataJson string `protobuf:"bytes,13,opt,name=client_data_json,json=clientDataJson,proto3" json:"client_data_json,omitempty"`
	// attestation_object is the base64url encoded attestation object
	AttestationObject string `protobuf:"bytes,14,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
}

func (x *WebAuthnCredential) Reset() {
	*x = WebAuthnCredential{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WebAuthnCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebAuthnCredential) ProtoMessage() {}

// Deprecated: Use WebAuthnCredential.ProtoReflect.Descriptor instead.
func (*WebAuthnCredential) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{4}
}

func (x *WebAuthnCredential) GetCredentialId() string {
	if x != nil {
		return x.CredentialId
	}
	return ""
}

func (x *WebAuthnCredential) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *WebAuthnCredential) GetAlgorithm() int32 {
	if x != nil {
		return x.Algorithm
	}
	return 0
}

func (x *WebAuthnCredential) GetAttestationType() string {
	if x != nil {
		return x.AttestationType
	}
	return ""
}

func (x *WebAuthnCredential) GetOrigin() string {
	if x != nil {
		return x.Origin
	}
	return ""
}

func (x *WebAuthnCredential) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *WebAuthnCredential) GetRpId() string {
	if x != nil {
		return x.RpId
	}
	return ""
}

func (x *WebAuthnCredential) GetRpName() string {
	if x != nil {
		return x.RpName
	}
	return ""
}

func (x *WebAuthnCredential) GetTransports() []string {
	if x != nil {
		return x.Transports
	}
	return nil
}

func (x *WebAuthnCredential) GetUserVerified() bool {
	if x != nil {
		return x.UserVerified
	}
	return false
}

func (x *WebAuthnCredential) GetSignatureAlgorithm() string {
	if x != nil {
		return x.SignatureAlgorithm
	}
	return ""
}

func (x *WebAuthnCredential) GetRawId() string {
	if x != nil {
		return x.RawId
	}
	return ""
}

func (x *WebAuthnCredential) GetClientDataJson() string {
	if x != nil {
		return x.ClientDataJson
	}
	return ""
}

func (x *WebAuthnCredential) GetAttestationObject() string {
	if x != nil {
		return x.AttestationObject
	}
	return ""
}

// CredentialProof represents a cryptographic proof for a verifiable
// credential
type CredentialProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// proof_kind is the proof type
	ProofKind string `protobuf:"bytes,1,opt,name=proof_kind,json=proofKind,proto3" json:"proof_kind,omitempty"`
	// created is when the proof was created
	Created string `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// verificationMethod is the verification method used
	VerificationMethod string `protobuf:"bytes,3,opt,name=verification_method,json=verificationMethod,proto3" json:"verification_method,omitempty"`
	// proofPurpose is the purpose of the proof
	ProofPurpose string `protobuf:"bytes,4,opt,name=proof_purpose,json=proofPurpose,proto3" json:"proof_purpose,omitempty"`
	// signature is the cryptographic signature
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	// Additional proof properties
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CredentialProof) Reset() {
	*x = CredentialProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CredentialProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialProof) ProtoMessage() {}

// Deprecated: Use CredentialProof.ProtoReflect.Descriptor instead.
func (*CredentialProof) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{5}
}

func (x *CredentialProof) GetProofKind() string {
	if x != nil {
		return x.ProofKind
	}
	return ""
}

func (x *CredentialProof) GetCreated() string {
	if x != nil {
		return x.Created
	}
	return ""
}

func (x *CredentialProof) GetVerificationMethod() string {
	if x != nil {
		return x.VerificationMethod
	}
	return ""
}

func (x *CredentialProof) GetProofPurpose() string {
	if x != nil {
		return x.ProofPurpose
	}
	return ""
}

func (x *CredentialProof) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *CredentialProof) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// CredentialStatus represents the revocation status of a credential
type CredentialStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the status identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// status_kind is the status type
	StatusKind string `protobuf:"bytes,2,opt,name=status_kind,json=statusKind,proto3" json:"status_kind,omitempty"`
	// Additional status properties
	Properties map[string]string `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CredentialStatus) Reset() {
	*x = CredentialStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_did_v1_types_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CredentialStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialStatus) ProtoMessage() {}

// Deprecated: Use CredentialStatus.ProtoReflect.Descriptor instead.
func (*CredentialStatus) Descriptor() ([]byte, []int) {
	return file_did_v1_types_proto_rawDescGZIP(), []int{6}
}

func (x *CredentialStatus) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CredentialStatus) GetStatusKind() string {
	if x != nil {
		return x.StatusKind
	}
	return ""
}

func (x *CredentialStatus) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

var File_did_v1_types_proto protoreflect.FileDescriptor

var file_did_v1_types_proto_rawDesc = []byte{
	0x0a, 0x12, 0x64, 0x69, 0x64, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x64, 0x69, 0x64, 0x2e, 0x76, 0x31, 0x1a, 0x11, 0x61, 0x6d,
	0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
	0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xfb, 0x03, 0x0a, 0x12, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69,
	0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x0e, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x38, 0x0a, 0x18,
	0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d, 0x65, 0x74,
	0x68, 0x6f, 0x64, 0x5f, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x16,
	0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68,
	0x6f, 0x64, 0x4b, 0x69, 0x6e, 0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f,
	0x6c, 0x6c, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x74,
	0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x24, 0x0a, 0x0e, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
	0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x6a, 0x77, 0x6b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x4a, 0x77, 0x6b, 0x12, 0x30, 0x0a, 0x14,
	0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69,
	0x62, 0x61, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x70, 0x75, 0x62, 0x6c,
	0x69, 0x63, 0x4b, 0x65, 0x79, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x62, 0x61, 0x73, 0x65, 0x12, 0x2a,
	0x0a, 0x11, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x62, 0x61, 0x73,
	0x65, 0x35, 0x38, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x75, 0x62, 0x6c, 0x69,
	0x63, 0x4b, 0x65, 0x79, 0x42, 0x61, 0x73, 0x65, 0x35, 0x38, 0x12, 0x2a, 0x0a, 0x11, 0x70, 0x75,
	0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79,
	0x42, 0x61, 0x73, 0x65, 0x36, 0x34, 0x12, 0x24, 0x0a, 0x0e, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
	0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x70, 0x65, 0x6d, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x50, 0x65, 0x6d, 0x12, 0x24, 0x0a, 0x0e,
	0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x68, 0x65, 0x78, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x48,
	0x65, 0x78, 0x12, 0x4b, 0x0a, 0x13, 0x77, 0x65, 0x62, 0x61, 0x75, 0x74, 0x68, 0x6e, 0x5f, 0x63,
	0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x64, 0x69, 0x64, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x65, 0x62, 0x41, 0x75, 0x74, 0x68,
	0x6e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x52, 0x12, 0x77, 0x65, 0x62,
	0x61, 0x75, 0x74, 0x68, 0x6e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x12,
	0x32, 0x0a, 0x15, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x5f, 0x61, 0x63,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x13,
	0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x49, 0x64, 0x22, 0xb1, 0x01, 0x0a, 0x1b, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65,
	0x6e, 0x63, 0x65, 0x12, 0x34, 0x0a, 0x16, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x14, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x49, 0x64, 0x12, 0x5c, 0x0a, 0x1c, 0x65, 0x6d, 0x62,
	0x65, 0x64, 0x64, 0x65, 0x64, 0x5f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x64, 0x69, 0x64, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x52, 0x1a, 0x65, 0x6d, 0x62,
	0x65, 0x64, 0x64, 0x65, 0x64, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x22, 0xd9, 0x02, 0x0a, 0x07, 0x53, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6b,
	0x69, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x4b, 0x69, 0x6e, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65,
	0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0e, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12,
	0x47, 0x0a, 0x12, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x5f, 0x65, 0x6e, 0x64, 0x70,
	0x6f, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x64, 0x69,
	0x64, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x64, 0x70,
	0x6f, 0x69, 0x6e, 0x74, 0x73, 0x52, 0x11, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x45,
	0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x6f, 0x6d, 0x70,
	0x6c, 0x65, 0x78, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x0f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x78, 0x45, 0x6e, 0x64, 0x70, 0x6f,
	0x69, 0x6e, 0x74, 0x12, 0x3f, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
	0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x64, 0x69, 0x64, 0x2e, 0x76, 0x31,
	0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
	0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72,
	0x74, 0x69, 0x65, 0x73, 0x1a, 0x3d, 0x0a, 0x0f, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69,
	0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
	0x02, 0x38, 0x01, 0x22, 0x30, 0x0a, 0x10, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e,
	0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x65, 0x6e, 0x64, 0x70, 0x6f,
	0x69, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x65, 0x6e, 0x64, 0x70,
	0x6f, 0x69, 0x6e, 0x74, 0x73, 0x22, 0xec, 0x03, 0x0a, 0x12, 0x57, 0x65, 0x62, 0x41, 0x75, 0x74,
	0x68, 0x6e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x12, 0x23, 0x0a, 0x0d,
	0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x49,
	0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79,
	0x12, 0x1c, 0x0a, 0x09, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x09, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x12, 0x29,
	0x0a, 0x10, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79,
	0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x72, 0x69,
	0x67, 0x69, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69,
	0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74,
	0x12, 0x13, 0x0a, 0x05, 0x72, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x72, 0x70, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x70, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x70, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1e,
	0x0a, 0x0a, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x09, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x0a, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x23,
	0x0a, 0x0d, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x65, 0x64, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x75, 0x73, 0x65, 0x72, 0x56, 0x65, 0x72, 0x69, 0x66,
	0x69, 0x65, 0x64, 0x12, 0x2f, 0x0a, 0x13, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65,
	0x5f, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x12, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x41, 0x6c, 0x67, 0x6f, 0x72,
	0x69, 0x74, 0x68, 0x6d, 0x12, 0x15, 0x0a, 0x06, 0x72, 0x61, 0x77, 0x5f, 0x69, 0x64, 0x18, 0x0c,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x72, 0x61, 0x77, 0x49, 0x64, 0x12, 0x28, 0x0a, 0x10, 0x63,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x6a, 0x73, 0x6f, 0x6e, 0x18,
	0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x44, 0x61, 0x74,
	0x61, 0x4a, 0x73, 0x6f, 0x6e, 0x12, 0x2d, 0x0a, 0x12, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x11, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x62,
	0x6a, 0x65, 0x63, 0x74, 0x22, 0xc6, 0x02, 0x0a, 0x0f, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
	0x69, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x6f,
	0x66, 0x5f, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x70, 0x72,
	0x6f, 0x6f, 0x66, 0x4b, 0x69, 0x6e, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x64, 0x12, 0x2f, 0x0a, 0x13, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12,
	0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68,
	0x6f, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x5f, 0x70, 0x75, 0x72, 0x70,
	0x6f, 0x73, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x70, 0x72, 0x6f, 0x6f, 0x66,
	0x50, 0x75, 0x72, 0x70, 0x6f, 0x73, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61,
	0x74, 0x75, 0x72, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x47, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
	0x69, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x64, 0x69, 0x64, 0x2e,
	0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x2e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x52, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x1a, 0x3d,
	0x0a, 0x0f, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xcc, 0x01,
	0x0a, 0x10, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x69, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x6b, 0x69, 0x6e,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x4b,
	0x69, 0x6e, 0x64, 0x12, 0x48, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
	0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x64, 0x69, 0x64, 0x2e, 0x76, 0x31,
	0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x2e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x52, 0x0a, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x1a, 0x3d, 0x0a,
	0x0f, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
	0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x7b, 0x0a, 0x0a,
	0x63, 0x6f, 0x6d, 0x2e, 0x64, 0x69, 0x64, 0x2e, 0x76, 0x31, 0x42, 0x0a, 0x54, 0x79, 0x70, 0x65,
	0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x28, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73, 0x6f, 0x6e, 0x72, 0x2d, 0x69, 0x6f, 0x2f, 0x73, 0x6f, 0x6e,
	0x72, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x64, 0x69, 0x64, 0x2f, 0x76, 0x31, 0x3b, 0x64, 0x69, 0x64,
	0x76, 0x31, 0xa2, 0x02, 0x03, 0x44, 0x58, 0x58, 0xaa, 0x02, 0x06, 0x44, 0x69, 0x64, 0x2e, 0x56,
	0x31, 0xca, 0x02, 0x06, 0x44, 0x69, 0x64, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x12, 0x44, 0x69, 0x64,
	0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea,
	0x02, 0x07, 0x44, 0x69, 0x64, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_did_v1_types_proto_rawDescOnce sync.Once
	file_did_v1_types_proto_rawDescData = file_did_v1_types_proto_rawDesc
)

func file_did_v1_types_proto_rawDescGZIP() []byte {
	file_did_v1_types_proto_rawDescOnce.Do(func() {
		file_did_v1_types_proto_rawDescData = protoimpl.X.CompressGZIP(file_did_v1_types_proto_rawDescData)
	})
	return file_did_v1_types_proto_rawDescData
}

var file_did_v1_types_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_did_v1_types_proto_goTypes = []interface{}{
	(*VerificationMethod)(nil),          // 0: did.v1.VerificationMethod
	(*VerificationMethodReference)(nil), // 1: did.v1.VerificationMethodReference
	(*Service)(nil),                     // 2: did.v1.Service
	(*ServiceEndpoints)(nil),            // 3: did.v1.ServiceEndpoints
	(*WebAuthnCredential)(nil),          // 4: did.v1.WebAuthnCredential
	(*CredentialProof)(nil),             // 5: did.v1.CredentialProof
	(*CredentialStatus)(nil),            // 6: did.v1.CredentialStatus
	nil,                                 // 7: did.v1.Service.PropertiesEntry
	nil,                                 // 8: did.v1.CredentialProof.PropertiesEntry
	nil,                                 // 9: did.v1.CredentialStatus.PropertiesEntry
}
var file_did_v1_types_proto_depIdxs = []int32{
	4, // 0: did.v1.VerificationMethod.webauthn_credential:type_name -> did.v1.WebAuthnCredential
	0, // 1: did.v1.VerificationMethodReference.embedded_verification_method:type_name -> did.v1.VerificationMethod
	3, // 2: did.v1.Service.multiple_endpoints:type_name -> did.v1.ServiceEndpoints
	7, // 3: did.v1.Service.properties:type_name -> did.v1.Service.PropertiesEntry
	8, // 4: did.v1.CredentialProof.properties:type_name -> did.v1.CredentialProof.PropertiesEntry
	9, // 5: did.v1.CredentialStatus.properties:type_name -> did.v1.CredentialStatus.PropertiesEntry
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_did_v1_types_proto_init() }
func file_did_v1_types_proto_init() {
	if File_did_v1_types_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_did_v1_types_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VerificationMethod); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_did_v1_types_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VerificationMethodReference); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_did_v1_types_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Service); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_did_v1_types_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ServiceEndpoints); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_did_v1_types_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WebAuthnCredential); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_did_v1_types_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CredentialProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_did_v1_types_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CredentialStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_did_v1_types_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_did_v1_types_proto_goTypes,
		DependencyIndexes: file_did_v1_types_proto_depIdxs,
		MessageInfos:      file_did_v1_types_proto_msgTypes,
	}.Build()
	File_did_v1_types_proto = out.File
	file_did_v1_types_proto_rawDesc = nil
	file_did_v1_types_proto_goTypes = nil
	file_did_v1_types_proto_depIdxs = nil
}
