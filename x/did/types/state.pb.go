// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: did/v1/state.proto

package types

import (
	_ "cosmossdk.io/orm"
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Authentication struct {
	// The unique identifier of the authentication
	Did string `protobuf:"bytes,1,opt,name=did,proto3" json:"did,omitempty"`
	// The authentication of the DID
	Controller string `protobuf:"bytes,2,opt,name=controller,proto3" json:"controller,omitempty"`
	// Origin of the authentication
	Subject string `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
	// PubKey is the verification method
	PublicKey *PubKey `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *Authentication) Reset()         { *m = Authentication{} }
func (m *Authentication) String() string { return proto.CompactTextString(m) }
func (*Authentication) ProtoMessage()    {}
func (*Authentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_f44bb702879c34b4, []int{0}
}
func (m *Authentication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Authentication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Authentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authentication.Merge(m, src)
}
func (m *Authentication) XXX_Size() int {
	return m.Size()
}
func (m *Authentication) XXX_DiscardUnknown() {
	xxx_messageInfo_Authentication.DiscardUnknown(m)
}

var xxx_messageInfo_Authentication proto.InternalMessageInfo

func (m *Authentication) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *Authentication) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *Authentication) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Authentication) GetPublicKey() *PubKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// Controller represents a Sonr DWN Vault
type Controller struct {
	// The unique identifier of the controller
	Number uint64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// The unique identifier of the controller
	Did string `protobuf:"bytes,2,opt,name=did,proto3" json:"did,omitempty"`
	// The DID of the controller
	SonrAddress string `protobuf:"bytes,3,opt,name=sonr_address,json=sonrAddress,proto3" json:"sonr_address,omitempty"`
	// The DID of the controller
	EthAddress string `protobuf:"bytes,4,opt,name=eth_address,json=ethAddress,proto3" json:"eth_address,omitempty"`
	// The DID of the controller
	BtcAddress string `protobuf:"bytes,5,opt,name=btc_address,json=btcAddress,proto3" json:"btc_address,omitempty"`
	// PubKey is the verification method
	PublicKey *PubKey `protobuf:"bytes,6,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Val Keyshare
	KsVal string `protobuf:"bytes,7,opt,name=ks_val,json=ksVal,proto3" json:"ks_val,omitempty"`
	// The Status of the claims for the controller
	Claimed bool `protobuf:"varint,8,opt,name=claimed,proto3" json:"claimed,omitempty"`
}

func (m *Controller) Reset()         { *m = Controller{} }
func (m *Controller) String() string { return proto.CompactTextString(m) }
func (*Controller) ProtoMessage()    {}
func (*Controller) Descriptor() ([]byte, []int) {
	return fileDescriptor_f44bb702879c34b4, []int{1}
}
func (m *Controller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Controller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Controller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Controller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Controller.Merge(m, src)
}
func (m *Controller) XXX_Size() int {
	return m.Size()
}
func (m *Controller) XXX_DiscardUnknown() {
	xxx_messageInfo_Controller.DiscardUnknown(m)
}

var xxx_messageInfo_Controller proto.InternalMessageInfo

func (m *Controller) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Controller) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *Controller) GetSonrAddress() string {
	if m != nil {
		return m.SonrAddress
	}
	return ""
}

func (m *Controller) GetEthAddress() string {
	if m != nil {
		return m.EthAddress
	}
	return ""
}

func (m *Controller) GetBtcAddress() string {
	if m != nil {
		return m.BtcAddress
	}
	return ""
}

func (m *Controller) GetPublicKey() *PubKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Controller) GetKsVal() string {
	if m != nil {
		return m.KsVal
	}
	return ""
}

func (m *Controller) GetClaimed() bool {
	if m != nil {
		return m.Claimed
	}
	return false
}

// Verification reprsents a method of verifying membership in a DID
type Verification struct {
	// The unique identifier of the verification
	Did string `protobuf:"bytes,1,opt,name=did,proto3" json:"did,omitempty"`
	// The controller of the verification
	Controller string `protobuf:"bytes,2,opt,name=controller,proto3" json:"controller,omitempty"`
	// The DIDNamespace of the verification
	DidMethod string `protobuf:"bytes,3,opt,name=did_method,json=didMethod,proto3" json:"did_method,omitempty"`
	// The value of the linked identifier
	Issuer string `protobuf:"bytes,4,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// The subject of the verification
	Subject string `protobuf:"bytes,5,opt,name=subject,proto3" json:"subject,omitempty"`
	// The public key of the verification
	PublicKey *PubKey `protobuf:"bytes,6,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// The Verification Type (Authentication, Assertion, CapabilityDelegation,
	// CapabilityInvocation)
	VerificationType string `protobuf:"bytes,7,opt,name=verification_type,json=verificationType,proto3" json:"verification_type,omitempty"`
}

func (m *Verification) Reset()         { *m = Verification{} }
func (m *Verification) String() string { return proto.CompactTextString(m) }
func (*Verification) ProtoMessage()    {}
func (*Verification) Descriptor() ([]byte, []int) {
	return fileDescriptor_f44bb702879c34b4, []int{2}
}
func (m *Verification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Verification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Verification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Verification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Verification.Merge(m, src)
}
func (m *Verification) XXX_Size() int {
	return m.Size()
}
func (m *Verification) XXX_DiscardUnknown() {
	xxx_messageInfo_Verification.DiscardUnknown(m)
}

var xxx_messageInfo_Verification proto.InternalMessageInfo

func (m *Verification) GetDid() string {
	if m != nil {
		return m.Did
	}
	return ""
}

func (m *Verification) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *Verification) GetDidMethod() string {
	if m != nil {
		return m.DidMethod
	}
	return ""
}

func (m *Verification) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *Verification) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Verification) GetPublicKey() *PubKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Verification) GetVerificationType() string {
	if m != nil {
		return m.VerificationType
	}
	return ""
}

// PubKey defines a public key for a did
type PubKey struct {
	Role    string      `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	KeyType string      `protobuf:"bytes,2,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	RawKey  *RawKey     `protobuf:"bytes,3,opt,name=raw_key,json=rawKey,proto3" json:"raw_key,omitempty"`
	Jwk     *JSONWebKey `protobuf:"bytes,4,opt,name=jwk,proto3" json:"jwk,omitempty"`
}

func (m *PubKey) Reset()         { *m = PubKey{} }
func (m *PubKey) String() string { return proto.CompactTextString(m) }
func (*PubKey) ProtoMessage()    {}
func (*PubKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f44bb702879c34b4, []int{3}
}
func (m *PubKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PubKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PubKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PubKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PubKey.Merge(m, src)
}
func (m *PubKey) XXX_Size() int {
	return m.Size()
}
func (m *PubKey) XXX_DiscardUnknown() {
	xxx_messageInfo_PubKey.DiscardUnknown(m)
}

var xxx_messageInfo_PubKey proto.InternalMessageInfo

func (m *PubKey) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *PubKey) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *PubKey) GetRawKey() *RawKey {
	if m != nil {
		return m.RawKey
	}
	return nil
}

func (m *PubKey) GetJwk() *JSONWebKey {
	if m != nil {
		return m.Jwk
	}
	return nil
}

// JWK represents a JSON Web Key
type JSONWebKey struct {
	Kty string `protobuf:"bytes,1,opt,name=kty,proto3" json:"kty,omitempty"`
	Crv string `protobuf:"bytes,2,opt,name=crv,proto3" json:"crv,omitempty"`
	X   string `protobuf:"bytes,3,opt,name=x,proto3" json:"x,omitempty"`
	Y   string `protobuf:"bytes,4,opt,name=y,proto3" json:"y,omitempty"`
	N   string `protobuf:"bytes,5,opt,name=n,proto3" json:"n,omitempty"`
	E   string `protobuf:"bytes,6,opt,name=e,proto3" json:"e,omitempty"`
}

func (m *JSONWebKey) Reset()         { *m = JSONWebKey{} }
func (m *JSONWebKey) String() string { return proto.CompactTextString(m) }
func (*JSONWebKey) ProtoMessage()    {}
func (*JSONWebKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f44bb702879c34b4, []int{4}
}
func (m *JSONWebKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JSONWebKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JSONWebKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JSONWebKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JSONWebKey.Merge(m, src)
}
func (m *JSONWebKey) XXX_Size() int {
	return m.Size()
}
func (m *JSONWebKey) XXX_DiscardUnknown() {
	xxx_messageInfo_JSONWebKey.DiscardUnknown(m)
}

var xxx_messageInfo_JSONWebKey proto.InternalMessageInfo

func (m *JSONWebKey) GetKty() string {
	if m != nil {
		return m.Kty
	}
	return ""
}

func (m *JSONWebKey) GetCrv() string {
	if m != nil {
		return m.Crv
	}
	return ""
}

func (m *JSONWebKey) GetX() string {
	if m != nil {
		return m.X
	}
	return ""
}

func (m *JSONWebKey) GetY() string {
	if m != nil {
		return m.Y
	}
	return ""
}

func (m *JSONWebKey) GetN() string {
	if m != nil {
		return m.N
	}
	return ""
}

func (m *JSONWebKey) GetE() string {
	if m != nil {
		return m.E
	}
	return ""
}

type RawKey struct {
	Algorithm string `protobuf:"bytes,1,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	Encoding  string `protobuf:"bytes,2,opt,name=encoding,proto3" json:"encoding,omitempty"`
	Curve     string `protobuf:"bytes,3,opt,name=curve,proto3" json:"curve,omitempty"`
	Key       []byte `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *RawKey) Reset()         { *m = RawKey{} }
func (m *RawKey) String() string { return proto.CompactTextString(m) }
func (*RawKey) ProtoMessage()    {}
func (*RawKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f44bb702879c34b4, []int{5}
}
func (m *RawKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawKey.Merge(m, src)
}
func (m *RawKey) XXX_Size() int {
	return m.Size()
}
func (m *RawKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RawKey.DiscardUnknown(m)
}

var xxx_messageInfo_RawKey proto.InternalMessageInfo

func (m *RawKey) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *RawKey) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *RawKey) GetCurve() string {
	if m != nil {
		return m.Curve
	}
	return ""
}

func (m *RawKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func init() {
	proto.RegisterType((*Authentication)(nil), "did.v1.Authentication")
	proto.RegisterType((*Controller)(nil), "did.v1.Controller")
	proto.RegisterType((*Verification)(nil), "did.v1.Verification")
	proto.RegisterType((*PubKey)(nil), "did.v1.PubKey")
	proto.RegisterType((*JSONWebKey)(nil), "did.v1.JSONWebKey")
	proto.RegisterType((*RawKey)(nil), "did.v1.RawKey")
}

func init() { proto.RegisterFile("did/v1/state.proto", fileDescriptor_f44bb702879c34b4) }

var fileDescriptor_f44bb702879c34b4 = []byte{
	// 699 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0xee, 0xe4, 0xc7, 0x49, 0x4e, 0xa3, 0x2a, 0x1d, 0xf5, 0xde, 0x3b, 0xb7, 0x2a, 0x21, 0x18,
	0x04, 0x45, 0x94, 0x44, 0x85, 0x5d, 0xc5, 0xa6, 0xb0, 0xa3, 0xe2, 0x47, 0x29, 0x2a, 0x82, 0x4d,
	0x64, 0x7b, 0x86, 0xc6, 0xf5, 0xcf, 0x84, 0xf1, 0xd8, 0xad, 0x5f, 0x80, 0x25, 0xe2, 0x09, 0x78,
	0x0c, 0x9e, 0x81, 0x65, 0x25, 0x24, 0xc4, 0xb2, 0x6a, 0xdf, 0x80, 0x27, 0x40, 0x33, 0x1e, 0x37,
	0x8e, 0x90, 0xa8, 0xc4, 0xc6, 0x9e, 0x73, 0xe6, 0xd3, 0x9c, 0xef, 0xfb, 0xce, 0x99, 0x01, 0x4c,
	0x7d, 0x3a, 0xca, 0xb6, 0x47, 0x89, 0x74, 0x24, 0x1b, 0xce, 0x04, 0x97, 0x1c, 0x5b, 0xd4, 0xa7,
	0xc3, 0x6c, 0x7b, 0xfd, 0x3f, 0x8f, 0x27, 0x11, 0x4f, 0x46, 0x5c, 0x44, 0x0a, 0xc2, 0x45, 0x54,
	0x00, 0xec, 0x2f, 0x08, 0x56, 0x76, 0x53, 0x39, 0x65, 0xb1, 0xf4, 0x3d, 0x47, 0xfa, 0x3c, 0xc6,
	0x3d, 0xa8, 0x53, 0x9f, 0x12, 0x34, 0x40, 0x9b, 0x9d, 0xb1, 0x5a, 0xe2, 0x3e, 0x80, 0xc7, 0x63,
	0x29, 0x78, 0x18, 0x32, 0x41, 0x6a, 0x7a, 0xa3, 0x92, 0xc1, 0x04, 0x5a, 0x49, 0xea, 0x1e, 0x31,
	0x4f, 0x92, 0xba, 0xde, 0x2c, 0x43, 0x7c, 0x1f, 0x60, 0x96, 0xba, 0xa1, 0xef, 0x4d, 0x02, 0x96,
	0x93, 0xc6, 0x00, 0x6d, 0x2e, 0x3f, 0x58, 0x19, 0x16, 0xa4, 0x86, 0x2f, 0x53, 0x77, 0x8f, 0xe5,
	0xe3, 0x4e, 0x81, 0xd8, 0x63, 0xf9, 0xce, 0xdd, 0x9f, 0x9f, 0xbf, 0x7d, 0xac, 0xdf, 0x84, 0xa6,
	0xa6, 0x80, 0x09, 0xe0, 0x79, 0x95, 0x2d, 0x73, 0x66, 0x0f, 0x11, 0x44, 0x90, 0xfd, 0xbd, 0x06,
	0xf0, 0x64, 0x4e, 0xe1, 0x5f, 0xb0, 0xe2, 0x34, 0x72, 0x99, 0xd0, 0xbc, 0x1b, 0x63, 0x13, 0x95,
	0x62, 0x6a, 0x73, 0x31, 0x37, 0xa0, 0x9b, 0xf0, 0x58, 0x4c, 0x1c, 0x4a, 0x05, 0x4b, 0x12, 0xc3,
	0x78, 0x59, 0xe5, 0x76, 0x8b, 0x14, 0xbe, 0x0e, 0xcb, 0x4c, 0x4e, 0x2f, 0x11, 0x8d, 0x42, 0x30,
	0x93, 0xd3, 0x0a, 0xc0, 0x95, 0xde, 0x25, 0xa0, 0x59, 0x00, 0x5c, 0xe9, 0x95, 0x80, 0x45, 0xdd,
	0xd6, 0x15, 0xba, 0xf1, 0x3f, 0x60, 0x05, 0xc9, 0x24, 0x73, 0x42, 0xd2, 0xd2, 0x47, 0x35, 0x83,
	0xe4, 0xc0, 0x09, 0x95, 0xaf, 0x5e, 0xe8, 0xf8, 0x11, 0xa3, 0xa4, 0x3d, 0x40, 0x9b, 0xed, 0x71,
	0x19, 0xee, 0xbc, 0xd1, 0x46, 0xed, 0x03, 0x94, 0xb2, 0x7b, 0x08, 0xe3, 0x45, 0x61, 0xca, 0x27,
	0xbc, 0xba, 0xa0, 0xa4, 0x57, 0x2b, 0x52, 0x15, 0xee, 0xbd, 0x3a, 0x41, 0xb8, 0xa3, 0x4d, 0xea,
	0x35, 0x08, 0x22, 0x35, 0xfb, 0xac, 0x06, 0xdd, 0x03, 0x26, 0xfc, 0x77, 0x7f, 0x3f, 0x0f, 0xd7,
	0x00, 0xa8, 0x4f, 0x27, 0x11, 0x93, 0x53, 0x4e, 0x8d, 0xc1, 0x1d, 0xea, 0xd3, 0x67, 0x3a, 0xa1,
	0x7a, 0xe5, 0x27, 0x49, 0xca, 0x84, 0x71, 0xd6, 0x44, 0xd5, 0x31, 0x6a, 0xfe, 0x69, 0x8c, 0xae,
	0xb4, 0xf3, 0x1e, 0xac, 0x66, 0x15, 0x05, 0x13, 0x99, 0xcf, 0x98, 0x71, 0xb6, 0x57, 0xdd, 0x78,
	0x95, 0xcf, 0xd8, 0xce, 0x7b, 0x6d, 0x65, 0x50, 0xce, 0xdc, 0x1a, 0xac, 0x14, 0x74, 0xaa, 0xf3,
	0x86, 0x6d, 0xd8, 0xa8, 0x4c, 0xe2, 0x5c, 0xdc, 0x56, 0x81, 0xd5, 0xc6, 0xde, 0x86, 0xc1, 0x6f,
	0x55, 0xcb, 0x43, 0x4a, 0x5c, 0x9d, 0x20, 0xd2, 0xb0, 0x3f, 0x20, 0xb0, 0x0a, 0xd6, 0x18, 0x43,
	0x43, 0xf0, 0x90, 0x19, 0x77, 0xf5, 0x1a, 0xff, 0x0f, 0xed, 0x80, 0xe5, 0x05, 0xeb, 0xc2, 0xdc,
	0x56, 0xc0, 0x72, 0x45, 0x16, 0xdf, 0x81, 0x96, 0x70, 0x8e, 0xb5, 0x0b, 0xf5, 0x45, 0x17, 0xc6,
	0xce, 0xb1, 0x72, 0xc1, 0x12, 0xfa, 0x8f, 0x6f, 0x41, 0xfd, 0xe8, 0x38, 0x30, 0x37, 0x0e, 0x97,
	0xa0, 0xa7, 0xfb, 0x2f, 0x9e, 0xbf, 0x66, 0xda, 0x2e, 0xb5, 0x6d, 0x4f, 0x01, 0xe6, 0x29, 0xd5,
	0xe8, 0x40, 0xe6, 0x65, 0xa3, 0x03, 0xa9, 0x33, 0x9e, 0xc8, 0xca, 0xdb, 0xe3, 0x89, 0x0c, 0x77,
	0x01, 0x9d, 0x98, 0x8e, 0xa2, 0x13, 0x15, 0xe5, 0xa6, 0x89, 0x28, 0x57, 0x51, 0x6c, 0x3a, 0x87,
	0x62, 0x15, 0x31, 0xdd, 0xaa, 0xce, 0x18, 0x31, 0xfb, 0x08, 0xac, 0x82, 0x21, 0xde, 0x80, 0x8e,
	0x13, 0x1e, 0x72, 0xe1, 0xcb, 0x69, 0x64, 0x6a, 0xcd, 0x13, 0x78, 0x1d, 0xda, 0x2c, 0xf6, 0x38,
	0xf5, 0xe3, 0x43, 0x53, 0xf6, 0x32, 0xc6, 0x6b, 0xd0, 0xf4, 0x52, 0x91, 0x31, 0x53, 0xbf, 0x08,
	0x34, 0x6b, 0xf3, 0xb6, 0x74, 0xc7, 0x6a, 0xf9, 0xf8, 0xd1, 0xd7, 0xf3, 0x3e, 0x3a, 0x3d, 0xef,
	0xa3, 0xb3, 0xf3, 0x3e, 0xfa, 0x74, 0xd1, 0x5f, 0x3a, 0xbd, 0xe8, 0x2f, 0xfd, 0xb8, 0xe8, 0x2f,
	0xbd, 0xb5, 0x0f, 0x7d, 0x39, 0x4d, 0xdd, 0xa1, 0xc7, 0xa3, 0x11, 0x8f, 0xd5, 0x6d, 0x19, 0xe9,
	0xcf, 0xc9, 0x48, 0xbd, 0x9d, 0xca, 0xf0, 0xc4, 0xb5, 0xf4, 0xc3, 0xf8, 0xf0, 0x57, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xd8, 0x36, 0xf8, 0xc5, 0x4f, 0x05, 0x00, 0x00,
}

func (m *Authentication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintState(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintState(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintState(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Controller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Controller) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Controller) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Claimed {
		i--
		if m.Claimed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.KsVal) > 0 {
		i -= len(m.KsVal)
		copy(dAtA[i:], m.KsVal)
		i = encodeVarintState(dAtA, i, uint64(len(m.KsVal)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.BtcAddress) > 0 {
		i -= len(m.BtcAddress)
		copy(dAtA[i:], m.BtcAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.BtcAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EthAddress) > 0 {
		i -= len(m.EthAddress)
		copy(dAtA[i:], m.EthAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.EthAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SonrAddress) > 0 {
		i -= len(m.SonrAddress)
		copy(dAtA[i:], m.SonrAddress)
		i = encodeVarintState(dAtA, i, uint64(len(m.SonrAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintState(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Verification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Verification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Verification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VerificationType) > 0 {
		i -= len(m.VerificationType)
		copy(dAtA[i:], m.VerificationType)
		i = encodeVarintState(dAtA, i, uint64(len(m.VerificationType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintState(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DidMethod) > 0 {
		i -= len(m.DidMethod)
		copy(dAtA[i:], m.DidMethod)
		i = encodeVarintState(dAtA, i, uint64(len(m.DidMethod)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintState(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Did) > 0 {
		i -= len(m.Did)
		copy(dAtA[i:], m.Did)
		i = encodeVarintState(dAtA, i, uint64(len(m.Did)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PubKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PubKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PubKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Jwk != nil {
		{
			size, err := m.Jwk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RawKey != nil {
		{
			size, err := m.RawKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintState(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintState(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JSONWebKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JSONWebKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JSONWebKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.E) > 0 {
		i -= len(m.E)
		copy(dAtA[i:], m.E)
		i = encodeVarintState(dAtA, i, uint64(len(m.E)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.N) > 0 {
		i -= len(m.N)
		copy(dAtA[i:], m.N)
		i = encodeVarintState(dAtA, i, uint64(len(m.N)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Y) > 0 {
		i -= len(m.Y)
		copy(dAtA[i:], m.Y)
		i = encodeVarintState(dAtA, i, uint64(len(m.Y)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.X) > 0 {
		i -= len(m.X)
		copy(dAtA[i:], m.X)
		i = encodeVarintState(dAtA, i, uint64(len(m.X)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crv) > 0 {
		i -= len(m.Crv)
		copy(dAtA[i:], m.Crv)
		i = encodeVarintState(dAtA, i, uint64(len(m.Crv)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kty) > 0 {
		i -= len(m.Kty)
		copy(dAtA[i:], m.Kty)
		i = encodeVarintState(dAtA, i, uint64(len(m.Kty)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintState(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Curve) > 0 {
		i -= len(m.Curve)
		copy(dAtA[i:], m.Curve)
		i = encodeVarintState(dAtA, i, uint64(len(m.Curve)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Encoding) > 0 {
		i -= len(m.Encoding)
		copy(dAtA[i:], m.Encoding)
		i = encodeVarintState(dAtA, i, uint64(len(m.Encoding)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Algorithm) > 0 {
		i -= len(m.Algorithm)
		copy(dAtA[i:], m.Algorithm)
		i = encodeVarintState(dAtA, i, uint64(len(m.Algorithm)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *Controller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovState(uint64(m.Number))
	}
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.SonrAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.EthAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.BtcAddress)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.KsVal)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Claimed {
		n += 2
	}
	return n
}

func (m *Verification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Did)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.DidMethod)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.VerificationType)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *PubKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.RawKey != nil {
		l = m.RawKey.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Jwk != nil {
		l = m.Jwk.Size()
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *JSONWebKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kty)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Crv)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Y)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.N)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.E)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *RawKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Algorithm)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Curve)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Authentication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authentication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authentication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PubKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Controller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Controller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Controller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SonrAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SonrAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BtcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PubKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KsVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KsVal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Claimed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Verification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Verification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Verification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Did = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DidMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DidMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PubKey{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PubKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PubKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PubKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RawKey == nil {
				m.RawKey = &RawKey{}
			}
			if err := m.RawKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jwk == nil {
				m.Jwk = &JSONWebKey{}
			}
			if err := m.Jwk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JSONWebKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JSONWebKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JSONWebKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crv = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.N = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.E = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
