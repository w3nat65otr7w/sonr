// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: did/v1/types.proto

package types

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VerificationMethod represents a verification method in a DID document
type VerificationMethod struct {
	// id is the verification method identifier (REQUIRED)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// verification_method_kind is the verification method type (REQUIRED)
	VerificationMethodKind string `protobuf:"bytes,2,opt,name=verification_method_kind,json=verificationMethodKind,proto3" json:"verification_method_kind,omitempty"`
	// controller is the DID that controls this verification method (REQUIRED)
	Controller string `protobuf:"bytes,3,opt,name=controller,proto3" json:"controller,omitempty"`
	// Public key material (optional, only one should be set)
	// publicKeyJwk represents the public key as a JSON Web Key
	PublicKeyJwk string `protobuf:"bytes,4,opt,name=public_key_jwk,json=publicKeyJwk,proto3" json:"public_key_jwk,omitempty"`
	// publicKeyMultibase represents the public key as multibase
	PublicKeyMultibase string `protobuf:"bytes,5,opt,name=public_key_multibase,json=publicKeyMultibase,proto3" json:"public_key_multibase,omitempty"`
	// publicKeyBase58 represents the public key in Base58 (legacy)
	PublicKeyBase58 string `protobuf:"bytes,6,opt,name=public_key_base58,json=publicKeyBase58,proto3" json:"public_key_base58,omitempty"`
	// publicKeyBase64 represents the public key in Base64 (legacy)
	PublicKeyBase64 string `protobuf:"bytes,7,opt,name=public_key_base64,json=publicKeyBase64,proto3" json:"public_key_base64,omitempty"`
	// publicKeyPem represents the public key in PEM format (legacy)
	PublicKeyPem string `protobuf:"bytes,8,opt,name=public_key_pem,json=publicKeyPem,proto3" json:"public_key_pem,omitempty"`
	// publicKeyHex represents the public key in hexadecimal (legacy)
	PublicKeyHex string `protobuf:"bytes,9,opt,name=public_key_hex,json=publicKeyHex,proto3" json:"public_key_hex,omitempty"`
	// WebAuthn credential information (for WebAuthn integration)
	WebauthnCredential *WebAuthnCredential `protobuf:"bytes,10,opt,name=webauthn_credential,json=webauthnCredential,proto3" json:"webauthn_credential,omitempty"`
	// blockchain_account_id for external wallet linking (CAIP-10 format)
	// Format: "eip155:1:0x89a932207c485f85226d86f7cd486a89a24fcc12" for Ethereum
	// Format: "cosmos:cosmoshub-4:cosmos1..." for Cosmos chains
	BlockchainAccountId string `protobuf:"bytes,11,opt,name=blockchain_account_id,json=blockchainAccountId,proto3" json:"blockchain_account_id,omitempty"`
}

func (m *VerificationMethod) Reset()         { *m = VerificationMethod{} }
func (m *VerificationMethod) String() string { return proto.CompactTextString(m) }
func (*VerificationMethod) ProtoMessage()    {}
func (*VerificationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{0}
}
func (m *VerificationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationMethod.Merge(m, src)
}
func (m *VerificationMethod) XXX_Size() int {
	return m.Size()
}
func (m *VerificationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationMethod proto.InternalMessageInfo

func (m *VerificationMethod) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VerificationMethod) GetVerificationMethodKind() string {
	if m != nil {
		return m.VerificationMethodKind
	}
	return ""
}

func (m *VerificationMethod) GetController() string {
	if m != nil {
		return m.Controller
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyJwk() string {
	if m != nil {
		return m.PublicKeyJwk
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyMultibase() string {
	if m != nil {
		return m.PublicKeyMultibase
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyBase58() string {
	if m != nil {
		return m.PublicKeyBase58
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyBase64() string {
	if m != nil {
		return m.PublicKeyBase64
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyPem() string {
	if m != nil {
		return m.PublicKeyPem
	}
	return ""
}

func (m *VerificationMethod) GetPublicKeyHex() string {
	if m != nil {
		return m.PublicKeyHex
	}
	return ""
}

func (m *VerificationMethod) GetWebauthnCredential() *WebAuthnCredential {
	if m != nil {
		return m.WebauthnCredential
	}
	return nil
}

func (m *VerificationMethod) GetBlockchainAccountId() string {
	if m != nil {
		return m.BlockchainAccountId
	}
	return ""
}

// VerificationMethodReference can be either an embedded verification method
// or a reference
type VerificationMethodReference struct {
	// verification_method_id is a reference to a verification method by ID (optional)
	VerificationMethodId string `protobuf:"bytes,1,opt,name=verification_method_id,json=verificationMethodId,proto3" json:"verification_method_id,omitempty"`
	// embedded_verification_method is an embedded verification method (optional)
	EmbeddedVerificationMethod *VerificationMethod `protobuf:"bytes,2,opt,name=embedded_verification_method,json=embeddedVerificationMethod,proto3" json:"embedded_verification_method,omitempty"`
}

func (m *VerificationMethodReference) Reset()         { *m = VerificationMethodReference{} }
func (m *VerificationMethodReference) String() string { return proto.CompactTextString(m) }
func (*VerificationMethodReference) ProtoMessage()    {}
func (*VerificationMethodReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{1}
}
func (m *VerificationMethodReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerificationMethodReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerificationMethodReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerificationMethodReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerificationMethodReference.Merge(m, src)
}
func (m *VerificationMethodReference) XXX_Size() int {
	return m.Size()
}
func (m *VerificationMethodReference) XXX_DiscardUnknown() {
	xxx_messageInfo_VerificationMethodReference.DiscardUnknown(m)
}

var xxx_messageInfo_VerificationMethodReference proto.InternalMessageInfo

func (m *VerificationMethodReference) GetVerificationMethodId() string {
	if m != nil {
		return m.VerificationMethodId
	}
	return ""
}

func (m *VerificationMethodReference) GetEmbeddedVerificationMethod() *VerificationMethod {
	if m != nil {
		return m.EmbeddedVerificationMethod
	}
	return nil
}

// Service represents a service endpoint in a DID document
type Service struct {
	// id is the service identifier (REQUIRED)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// service_kind is the service type (REQUIRED)
	ServiceKind string `protobuf:"bytes,2,opt,name=service_kind,json=serviceKind,proto3" json:"service_kind,omitempty"`
	// single_endpoint for a single URL
	SingleEndpoint string `protobuf:"bytes,3,opt,name=single_endpoint,json=singleEndpoint,proto3" json:"single_endpoint,omitempty"`
	// multiple_endpoints for multiple URLs
	MultipleEndpoints *ServiceEndpoints `protobuf:"bytes,4,opt,name=multiple_endpoints,json=multipleEndpoints,proto3" json:"multiple_endpoints,omitempty"`
	// complex_endpoint for complex endpoint objects as JSON
	ComplexEndpoint []byte `protobuf:"bytes,5,opt,name=complex_endpoint,json=complexEndpoint,proto3" json:"complex_endpoint,omitempty"`
	// Additional properties for the service
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{2}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Service) GetServiceKind() string {
	if m != nil {
		return m.ServiceKind
	}
	return ""
}

func (m *Service) GetSingleEndpoint() string {
	if m != nil {
		return m.SingleEndpoint
	}
	return ""
}

func (m *Service) GetMultipleEndpoints() *ServiceEndpoints {
	if m != nil {
		return m.MultipleEndpoints
	}
	return nil
}

func (m *Service) GetComplexEndpoint() []byte {
	if m != nil {
		return m.ComplexEndpoint
	}
	return nil
}

func (m *Service) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

// ServiceEndpoints represents multiple service endpoints
type ServiceEndpoints struct {
	Endpoints []string `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
}

func (m *ServiceEndpoints) Reset()         { *m = ServiceEndpoints{} }
func (m *ServiceEndpoints) String() string { return proto.CompactTextString(m) }
func (*ServiceEndpoints) ProtoMessage()    {}
func (*ServiceEndpoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{3}
}
func (m *ServiceEndpoints) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceEndpoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceEndpoints.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceEndpoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceEndpoints.Merge(m, src)
}
func (m *ServiceEndpoints) XXX_Size() int {
	return m.Size()
}
func (m *ServiceEndpoints) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceEndpoints.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceEndpoints proto.InternalMessageInfo

func (m *ServiceEndpoints) GetEndpoints() []string {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// WebAuthnCredential represents WebAuthn credential information
type WebAuthnCredential struct {
	// credential_id is the WebAuthn credential ID
	CredentialId string `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// public_key is the WebAuthn public key
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// algorithm is the signing algorithm
	Algorithm int32 `protobuf:"varint,3,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	// attestation_type is the attestation type
	AttestationType string `protobuf:"bytes,4,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty"`
	// origin is the origin where the credential was created
	Origin string `protobuf:"bytes,5,opt,name=origin,proto3" json:"origin,omitempty"`
	// created_at is when the credential was created
	CreatedAt int64 `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// rp_id is the Relying Party ID
	RpId string `protobuf:"bytes,7,opt,name=rp_id,json=rpId,proto3" json:"rp_id,omitempty"`
	// rp_name is the Relying Party Name
	RpName string `protobuf:"bytes,8,opt,name=rp_name,json=rpName,proto3" json:"rp_name,omitempty"`
	// transports are the authenticator transports
	Transports []string `protobuf:"bytes,9,rep,name=transports,proto3" json:"transports,omitempty"`
	// user_verified indicates whether user verification was performed
	UserVerified bool `protobuf:"varint,10,opt,name=user_verified,json=userVerified,proto3" json:"user_verified,omitempty"`
	// signature_algorithm provides detailed algorithm information
	SignatureAlgorithm string `protobuf:"bytes,11,opt,name=signature_algorithm,json=signatureAlgorithm,proto3" json:"signature_algorithm,omitempty"`
	// raw_id is the base64url encoded raw credential ID
	RawId string `protobuf:"bytes,12,opt,name=raw_id,json=rawId,proto3" json:"raw_id,omitempty"`
	// client_data_json is the base64url encoded client data JSON
	ClientDataJson string `protobuf:"bytes,13,opt,name=client_data_json,json=clientDataJson,proto3" json:"client_data_json,omitempty"`
	// attestation_object is the base64url encoded attestation object
	AttestationObject string `protobuf:"bytes,14,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
}

func (m *WebAuthnCredential) Reset()         { *m = WebAuthnCredential{} }
func (m *WebAuthnCredential) String() string { return proto.CompactTextString(m) }
func (*WebAuthnCredential) ProtoMessage()    {}
func (*WebAuthnCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{4}
}
func (m *WebAuthnCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebAuthnCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebAuthnCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebAuthnCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebAuthnCredential.Merge(m, src)
}
func (m *WebAuthnCredential) XXX_Size() int {
	return m.Size()
}
func (m *WebAuthnCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_WebAuthnCredential.DiscardUnknown(m)
}

var xxx_messageInfo_WebAuthnCredential proto.InternalMessageInfo

func (m *WebAuthnCredential) GetCredentialId() string {
	if m != nil {
		return m.CredentialId
	}
	return ""
}

func (m *WebAuthnCredential) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *WebAuthnCredential) GetAlgorithm() int32 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *WebAuthnCredential) GetAttestationType() string {
	if m != nil {
		return m.AttestationType
	}
	return ""
}

func (m *WebAuthnCredential) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

func (m *WebAuthnCredential) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *WebAuthnCredential) GetRpId() string {
	if m != nil {
		return m.RpId
	}
	return ""
}

func (m *WebAuthnCredential) GetRpName() string {
	if m != nil {
		return m.RpName
	}
	return ""
}

func (m *WebAuthnCredential) GetTransports() []string {
	if m != nil {
		return m.Transports
	}
	return nil
}

func (m *WebAuthnCredential) GetUserVerified() bool {
	if m != nil {
		return m.UserVerified
	}
	return false
}

func (m *WebAuthnCredential) GetSignatureAlgorithm() string {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return ""
}

func (m *WebAuthnCredential) GetRawId() string {
	if m != nil {
		return m.RawId
	}
	return ""
}

func (m *WebAuthnCredential) GetClientDataJson() string {
	if m != nil {
		return m.ClientDataJson
	}
	return ""
}

func (m *WebAuthnCredential) GetAttestationObject() string {
	if m != nil {
		return m.AttestationObject
	}
	return ""
}

// CredentialProof represents a cryptographic proof for a verifiable
// credential
type CredentialProof struct {
	// proof_kind is the proof type
	ProofKind string `protobuf:"bytes,1,opt,name=proof_kind,json=proofKind,proto3" json:"proof_kind,omitempty"`
	// created is when the proof was created
	Created string `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// verificationMethod is the verification method used
	VerificationMethod string `protobuf:"bytes,3,opt,name=verification_method,json=verificationMethod,proto3" json:"verification_method,omitempty"`
	// proofPurpose is the purpose of the proof
	ProofPurpose string `protobuf:"bytes,4,opt,name=proof_purpose,json=proofPurpose,proto3" json:"proof_purpose,omitempty"`
	// signature is the cryptographic signature
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	// Additional proof properties
	Properties map[string]string `protobuf:"bytes,6,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CredentialProof) Reset()         { *m = CredentialProof{} }
func (m *CredentialProof) String() string { return proto.CompactTextString(m) }
func (*CredentialProof) ProtoMessage()    {}
func (*CredentialProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{5}
}
func (m *CredentialProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialProof.Merge(m, src)
}
func (m *CredentialProof) XXX_Size() int {
	return m.Size()
}
func (m *CredentialProof) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialProof.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialProof proto.InternalMessageInfo

func (m *CredentialProof) GetProofKind() string {
	if m != nil {
		return m.ProofKind
	}
	return ""
}

func (m *CredentialProof) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *CredentialProof) GetVerificationMethod() string {
	if m != nil {
		return m.VerificationMethod
	}
	return ""
}

func (m *CredentialProof) GetProofPurpose() string {
	if m != nil {
		return m.ProofPurpose
	}
	return ""
}

func (m *CredentialProof) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *CredentialProof) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

// CredentialStatus represents the revocation status of a credential
type CredentialStatus struct {
	// id is the status identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// status_kind is the status type
	StatusKind string `protobuf:"bytes,2,opt,name=status_kind,json=statusKind,proto3" json:"status_kind,omitempty"`
	// Additional status properties
	Properties map[string]string `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CredentialStatus) Reset()         { *m = CredentialStatus{} }
func (m *CredentialStatus) String() string { return proto.CompactTextString(m) }
func (*CredentialStatus) ProtoMessage()    {}
func (*CredentialStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_e3176cd2dbe76ac1, []int{6}
}
func (m *CredentialStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialStatus.Merge(m, src)
}
func (m *CredentialStatus) XXX_Size() int {
	return m.Size()
}
func (m *CredentialStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialStatus proto.InternalMessageInfo

func (m *CredentialStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CredentialStatus) GetStatusKind() string {
	if m != nil {
		return m.StatusKind
	}
	return ""
}

func (m *CredentialStatus) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

func init() {
	proto.RegisterType((*VerificationMethod)(nil), "did.v1.VerificationMethod")
	proto.RegisterType((*VerificationMethodReference)(nil), "did.v1.VerificationMethodReference")
	proto.RegisterType((*Service)(nil), "did.v1.Service")
	proto.RegisterMapType((map[string]string)(nil), "did.v1.Service.PropertiesEntry")
	proto.RegisterType((*ServiceEndpoints)(nil), "did.v1.ServiceEndpoints")
	proto.RegisterType((*WebAuthnCredential)(nil), "did.v1.WebAuthnCredential")
	proto.RegisterType((*CredentialProof)(nil), "did.v1.CredentialProof")
	proto.RegisterMapType((map[string]string)(nil), "did.v1.CredentialProof.PropertiesEntry")
	proto.RegisterType((*CredentialStatus)(nil), "did.v1.CredentialStatus")
	proto.RegisterMapType((map[string]string)(nil), "did.v1.CredentialStatus.PropertiesEntry")
}

func init() { proto.RegisterFile("did/v1/types.proto", fileDescriptor_e3176cd2dbe76ac1) }

var fileDescriptor_e3176cd2dbe76ac1 = []byte{
	// 988 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0xb6, 0xa4, 0x58, 0x8e, 0x46, 0x8a, 0x65, 0xaf, 0x1d, 0xff, 0x08, 0xff, 0x52, 0xc5, 0x55,
	0x0a, 0x44, 0x2d, 0x10, 0x29, 0x71, 0xdd, 0xc0, 0x28, 0x10, 0x14, 0x4e, 0x1b, 0x24, 0x8e, 0x91,
	0xd6, 0x60, 0x8a, 0x14, 0x28, 0x0a, 0x10, 0x2b, 0xee, 0x58, 0x5a, 0x8b, 0xdc, 0x25, 0x96, 0x2b,
	0xc9, 0x7a, 0x8b, 0xbe, 0x4a, 0x5f, 0xa2, 0xe8, 0xa1, 0x87, 0x1c, 0xdb, 0x5b, 0x61, 0x5f, 0xfb,
	0x06, 0xbd, 0x14, 0xdc, 0xa5, 0x48, 0x56, 0xd2, 0x35, 0x17, 0x7b, 0xf9, 0xcd, 0xb7, 0x9c, 0x7f,
	0xdf, 0x8c, 0x08, 0x84, 0x71, 0xd6, 0x9b, 0x3c, 0xe9, 0xe9, 0x59, 0x84, 0x71, 0x37, 0x52, 0x52,
	0x4b, 0x52, 0x65, 0x9c, 0x75, 0x27, 0x4f, 0xf6, 0xb7, 0x69, 0xc8, 0x85, 0xec, 0x99, 0xbf, 0xd6,
	0xb4, 0xbf, 0x3b, 0x90, 0x03, 0x69, 0x8e, 0xbd, 0xe4, 0x64, 0xd1, 0xf6, 0x3f, 0x15, 0x20, 0xef,
	0x50, 0xf1, 0x0b, 0xee, 0x53, 0xcd, 0xa5, 0x78, 0x83, 0x7a, 0x28, 0x19, 0xd9, 0x84, 0x32, 0x67,
	0x4e, 0xe9, 0xa0, 0xd4, 0xa9, 0xb9, 0x65, 0xce, 0xc8, 0x31, 0x38, 0x93, 0x02, 0xcb, 0x0b, 0x0d,
	0xcd, 0x1b, 0x71, 0xc1, 0x9c, 0xb2, 0x61, 0xed, 0x4d, 0x96, 0xde, 0x72, 0xc6, 0x05, 0x23, 0x2d,
	0x00, 0x5f, 0x0a, 0xad, 0x64, 0x10, 0xa0, 0x72, 0x2a, 0x86, 0x5b, 0x40, 0xc8, 0x27, 0xb0, 0x19,
	0x8d, 0xfb, 0x01, 0xf7, 0xbd, 0x11, 0xce, 0xbc, 0xcb, 0xe9, 0xc8, 0xb9, 0x65, 0x38, 0x0d, 0x8b,
	0x9e, 0xe1, 0xec, 0xf5, 0x74, 0x44, 0x1e, 0xc3, 0x6e, 0x81, 0x15, 0x8e, 0x03, 0xcd, 0xfb, 0x34,
	0x46, 0x67, 0xdd, 0x70, 0x49, 0xc6, 0x7d, 0x33, 0xb7, 0x90, 0xcf, 0x60, 0xbb, 0x70, 0x23, 0x81,
	0xbe, 0x38, 0x76, 0xaa, 0x86, 0xde, 0xcc, 0xe8, 0xcf, 0x0d, 0xbc, 0x82, 0xfb, 0xf4, 0xc8, 0xd9,
	0x58, 0xc1, 0x7d, 0x7a, 0xb4, 0x10, 0x6f, 0x84, 0xa1, 0x73, 0x7b, 0x21, 0xde, 0x73, 0x0c, 0x17,
	0x58, 0x43, 0xbc, 0x72, 0x6a, 0x0b, 0xac, 0x57, 0x78, 0x45, 0xce, 0x60, 0x67, 0x8a, 0x7d, 0x3a,
	0xd6, 0x43, 0xe1, 0xf9, 0x0a, 0x19, 0x0a, 0xcd, 0x69, 0xe0, 0xc0, 0x41, 0xa9, 0x53, 0x3f, 0xdc,
	0xef, 0xda, 0x5e, 0x76, 0x7f, 0xc0, 0xfe, 0x49, 0x42, 0xf9, 0x3a, 0x63, 0xb8, 0x64, 0x7e, 0x2d,
	0xc7, 0xc8, 0x21, 0xdc, 0xed, 0x07, 0xd2, 0x1f, 0xf9, 0x43, 0xca, 0x85, 0x47, 0x7d, 0x5f, 0x8e,
	0x85, 0xf6, 0x38, 0x73, 0xea, 0xc6, 0xf3, 0x4e, 0x6e, 0x3c, 0xb1, 0xb6, 0x53, 0xd6, 0xfe, 0xa5,
	0x04, 0xff, 0x5f, 0xee, 0xbe, 0x8b, 0x17, 0xa8, 0x50, 0xf8, 0x48, 0x8e, 0x60, 0x6f, 0x55, 0xdb,
	0x33, 0x69, 0xec, 0x2e, 0x37, 0xfd, 0x94, 0x91, 0x9f, 0xe0, 0x1e, 0x86, 0x7d, 0x64, 0x0c, 0x99,
	0xb7, 0xe2, 0xba, 0x11, 0x4c, 0x21, 0xbf, 0x15, 0x01, 0xec, 0xcf, 0xef, 0x2f, 0xdb, 0xda, 0x7f,
	0x96, 0x61, 0xe3, 0x2d, 0xaa, 0x09, 0xf7, 0x71, 0x49, 0xa6, 0x1f, 0x43, 0x23, 0xb6, 0xa6, 0xa2,
	0x34, 0xeb, 0x29, 0x66, 0xf4, 0xf8, 0x10, 0x9a, 0x31, 0x17, 0x83, 0x00, 0x3d, 0x14, 0x2c, 0x92,
	0x5c, 0xe8, 0x54, 0x94, 0x9b, 0x16, 0x7e, 0x91, 0xa2, 0xe4, 0x25, 0x10, 0xa3, 0xb3, 0xa8, 0x40,
	0x8d, 0x8d, 0x38, 0xeb, 0x87, 0xce, 0x3c, 0xf6, 0x34, 0x90, 0xf9, 0xa5, 0xd8, 0xdd, 0x9e, 0xdf,
	0xc9, 0x20, 0xf2, 0x29, 0x6c, 0xf9, 0x32, 0x8c, 0x02, 0xbc, 0xca, 0x5d, 0x26, 0xba, 0x6d, 0xb8,
	0xcd, 0x14, 0xcf, 0x7c, 0x7e, 0x05, 0x10, 0x29, 0x19, 0xa1, 0xd2, 0x1c, 0x63, 0xa7, 0x7a, 0x50,
	0xe9, 0xd4, 0x0f, 0xef, 0x2f, 0xf8, 0xea, 0x9e, 0x67, 0x8c, 0x17, 0x42, 0xab, 0x99, 0x5b, 0xb8,
	0xb2, 0xff, 0x0c, 0x9a, 0x0b, 0x66, 0xb2, 0x05, 0x95, 0x11, 0xce, 0xd2, 0x22, 0x25, 0x47, 0xb2,
	0x0b, 0xeb, 0x13, 0x1a, 0x8c, 0x31, 0x2d, 0x8f, 0x7d, 0xf8, 0xb2, 0x7c, 0x5c, 0x6a, 0x3f, 0x86,
	0xad, 0xc5, 0x8c, 0xc8, 0x3d, 0xa8, 0xe5, 0xe9, 0x97, 0x0e, 0x2a, 0x9d, 0x9a, 0x9b, 0x03, 0xed,
	0xbf, 0x2b, 0x40, 0x96, 0x05, 0x4a, 0x1e, 0xc0, 0x9d, 0x5c, 0xd0, 0xb9, 0x5e, 0x1a, 0x39, 0x78,
	0xca, 0xc8, 0x47, 0x00, 0xf9, 0x90, 0x98, 0x60, 0x1a, 0x6e, 0x2d, 0x1b, 0x90, 0xc4, 0x31, 0x0d,
	0x06, 0x52, 0x71, 0x3d, 0x0c, 0x4d, 0x8f, 0xd6, 0xdd, 0x1c, 0x48, 0xaa, 0x4a, 0xb5, 0xc6, 0x58,
	0x5b, 0x69, 0x25, 0x4b, 0x30, 0xdd, 0x1c, 0xcd, 0x02, 0xfe, 0xfd, 0x2c, 0x42, 0xb2, 0x07, 0x55,
	0xa9, 0xf8, 0x80, 0x8b, 0x74, 0x5d, 0xa4, 0x4f, 0x89, 0x7f, 0x5f, 0x21, 0xd5, 0xc8, 0x3c, 0xaa,
	0xcd, 0x6e, 0xa8, 0xb8, 0xb5, 0x14, 0x39, 0xd1, 0x64, 0x07, 0xd6, 0x55, 0x94, 0xc4, 0x6e, 0x37,
	0xc1, 0x2d, 0x15, 0x9d, 0x32, 0xf2, 0x3f, 0xd8, 0x50, 0x91, 0x27, 0x68, 0x88, 0xe9, 0xdc, 0x57,
	0x55, 0xf4, 0x2d, 0x0d, 0x31, 0xd9, 0x73, 0x5a, 0x51, 0x11, 0x47, 0x52, 0xe9, 0xd8, 0xa9, 0x99,
	0x3a, 0x15, 0x90, 0xa4, 0x22, 0xe3, 0x18, 0x55, 0x3a, 0x10, 0xc8, 0xcc, 0x94, 0xdf, 0x76, 0x1b,
	0x09, 0xf8, 0x2e, 0xc5, 0x48, 0x0f, 0x76, 0x62, 0x3e, 0x10, 0x54, 0x8f, 0x15, 0x7a, 0x79, 0xf2,
	0x76, 0x82, 0x49, 0x66, 0x3a, 0xc9, 0xaa, 0x70, 0x17, 0xaa, 0x8a, 0x4e, 0x93, 0x20, 0x1b, 0xb6,
	0x97, 0x8a, 0x4e, 0x4f, 0x19, 0xe9, 0xc0, 0x96, 0x1f, 0x70, 0x14, 0xda, 0x63, 0x54, 0x53, 0xef,
	0x32, 0x96, 0xc2, 0xb9, 0x63, 0x55, 0x6e, 0xf1, 0x6f, 0xa8, 0xa6, 0xaf, 0x63, 0x29, 0xc8, 0x23,
	0x20, 0xc5, 0x32, 0xca, 0xfe, 0x25, 0xfa, 0xda, 0xd9, 0x34, 0xdc, 0xed, 0x82, 0xe5, 0x3b, 0x63,
	0x68, 0xff, 0x5a, 0x86, 0x66, 0xde, 0xe6, 0x73, 0x25, 0xe5, 0x85, 0x69, 0x63, 0x72, 0xb0, 0x23,
	0x67, 0x1b, 0x5d, 0x33, 0x88, 0x19, 0x38, 0x07, 0x36, 0xd2, 0x9a, 0xa6, 0x7a, 0x9b, 0x3f, 0x26,
	0xd9, 0xae, 0x5a, 0x0f, 0x76, 0x1c, 0xc9, 0xf2, 0x6a, 0x49, 0x6a, 0x68, 0x3d, 0x45, 0x63, 0x15,
	0xc9, 0x18, 0xb3, 0x9f, 0x8a, 0x04, 0x3c, 0xb7, 0x58, 0x22, 0x9b, 0xac, 0x50, 0x69, 0xc3, 0x73,
	0x80, 0xbc, 0x5c, 0x31, 0x61, 0x0f, 0xe7, 0x13, 0xb6, 0x90, 0xd9, 0x87, 0x9c, 0xb4, 0xdf, 0x4b,
	0xb0, 0x95, 0xbb, 0x7b, 0xab, 0xa9, 0x1e, 0xc7, 0x4b, 0xeb, 0xec, 0x3e, 0xd4, 0x63, 0x63, 0x29,
	0x6e, 0x33, 0xb0, 0x90, 0xa9, 0xed, 0xab, 0xff, 0x64, 0x53, 0x31, 0xd9, 0x74, 0x96, 0xb3, 0xb1,
	0xaf, 0xff, 0x80, 0xe9, 0x3c, 0x7f, 0xf6, 0xdb, 0x75, 0xab, 0xf4, 0xfe, 0xba, 0x55, 0xfa, 0xeb,
	0xba, 0x55, 0xfa, 0xf9, 0xa6, 0xb5, 0xf6, 0xfe, 0xa6, 0xb5, 0xf6, 0xc7, 0x4d, 0x6b, 0xed, 0xc7,
	0x07, 0x03, 0xae, 0x87, 0xe3, 0x7e, 0xd7, 0x97, 0x61, 0x2f, 0x96, 0x42, 0x3d, 0xe2, 0xd2, 0xfc,
	0xef, 0x5d, 0xf5, 0x92, 0xef, 0x17, 0xf3, 0xf1, 0xd2, 0xaf, 0x9a, 0x8f, 0x91, 0xcf, 0xff, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0x86, 0x7f, 0xe1, 0x22, 0xd3, 0x08, 0x00, 0x00,
}

func (m *VerificationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockchainAccountId) > 0 {
		i -= len(m.BlockchainAccountId)
		copy(dAtA[i:], m.BlockchainAccountId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlockchainAccountId)))
		i--
		dAtA[i] = 0x5a
	}
	if m.WebauthnCredential != nil {
		{
			size, err := m.WebauthnCredential.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.PublicKeyHex) > 0 {
		i -= len(m.PublicKeyHex)
		copy(dAtA[i:], m.PublicKeyHex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyHex)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PublicKeyPem) > 0 {
		i -= len(m.PublicKeyPem)
		copy(dAtA[i:], m.PublicKeyPem)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyPem)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PublicKeyBase64) > 0 {
		i -= len(m.PublicKeyBase64)
		copy(dAtA[i:], m.PublicKeyBase64)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyBase64)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PublicKeyBase58) > 0 {
		i -= len(m.PublicKeyBase58)
		copy(dAtA[i:], m.PublicKeyBase58)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyBase58)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PublicKeyMultibase) > 0 {
		i -= len(m.PublicKeyMultibase)
		copy(dAtA[i:], m.PublicKeyMultibase)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyMultibase)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicKeyJwk) > 0 {
		i -= len(m.PublicKeyJwk)
		copy(dAtA[i:], m.PublicKeyJwk)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyJwk)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Controller) > 0 {
		i -= len(m.Controller)
		copy(dAtA[i:], m.Controller)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Controller)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VerificationMethodKind) > 0 {
		i -= len(m.VerificationMethodKind)
		copy(dAtA[i:], m.VerificationMethodKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerificationMethodKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerificationMethodReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerificationMethodReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerificationMethodReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EmbeddedVerificationMethod != nil {
		{
			size, err := m.EmbeddedVerificationMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerificationMethodId) > 0 {
		i -= len(m.VerificationMethodId)
		copy(dAtA[i:], m.VerificationMethodId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerificationMethodId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ComplexEndpoint) > 0 {
		i -= len(m.ComplexEndpoint)
		copy(dAtA[i:], m.ComplexEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ComplexEndpoint)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MultipleEndpoints != nil {
		{
			size, err := m.MultipleEndpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SingleEndpoint) > 0 {
		i -= len(m.SingleEndpoint)
		copy(dAtA[i:], m.SingleEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SingleEndpoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceKind) > 0 {
		i -= len(m.ServiceKind)
		copy(dAtA[i:], m.ServiceKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceEndpoints) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceEndpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceEndpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Endpoints[iNdEx])
			copy(dAtA[i:], m.Endpoints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Endpoints[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WebAuthnCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebAuthnCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebAuthnCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationObject) > 0 {
		i -= len(m.AttestationObject)
		copy(dAtA[i:], m.AttestationObject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationObject)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ClientDataJson) > 0 {
		i -= len(m.ClientDataJson)
		copy(dAtA[i:], m.ClientDataJson)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientDataJson)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RawId) > 0 {
		i -= len(m.RawId)
		copy(dAtA[i:], m.RawId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SignatureAlgorithm) > 0 {
		i -= len(m.SignatureAlgorithm)
		copy(dAtA[i:], m.SignatureAlgorithm)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SignatureAlgorithm)))
		i--
		dAtA[i] = 0x5a
	}
	if m.UserVerified {
		i--
		if m.UserVerified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Transports) > 0 {
		for iNdEx := len(m.Transports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Transports[iNdEx])
			copy(dAtA[i:], m.Transports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Transports[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RpName) > 0 {
		i -= len(m.RpName)
		copy(dAtA[i:], m.RpName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RpName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RpId) > 0 {
		i -= len(m.RpId)
		copy(dAtA[i:], m.RpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RpId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Origin) > 0 {
		i -= len(m.Origin)
		copy(dAtA[i:], m.Origin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Origin)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AttestationType) > 0 {
		i -= len(m.AttestationType)
		copy(dAtA[i:], m.AttestationType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Algorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProofPurpose) > 0 {
		i -= len(m.ProofPurpose)
		copy(dAtA[i:], m.ProofPurpose)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProofPurpose)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VerificationMethod) > 0 {
		i -= len(m.VerificationMethod)
		copy(dAtA[i:], m.VerificationMethod)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerificationMethod)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Created) > 0 {
		i -= len(m.Created)
		copy(dAtA[i:], m.Created)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Created)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProofKind) > 0 {
		i -= len(m.ProofKind)
		copy(dAtA[i:], m.ProofKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProofKind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StatusKind) > 0 {
		i -= len(m.StatusKind)
		copy(dAtA[i:], m.StatusKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StatusKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerificationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VerificationMethodKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Controller)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyJwk)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyMultibase)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyBase58)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyBase64)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyPem)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyHex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WebauthnCredential != nil {
		l = m.WebauthnCredential.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BlockchainAccountId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VerificationMethodReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerificationMethodId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EmbeddedVerificationMethod != nil {
		l = m.EmbeddedVerificationMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SingleEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MultipleEndpoints != nil {
		l = m.MultipleEndpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ComplexEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ServiceEndpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, s := range m.Endpoints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WebAuthnCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Algorithm != 0 {
		n += 1 + sovTypes(uint64(m.Algorithm))
	}
	l = len(m.AttestationType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Origin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	l = len(m.RpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RpName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Transports) > 0 {
		for _, s := range m.Transports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UserVerified {
		n += 2
	}
	l = len(m.SignatureAlgorithm)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RawId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientDataJson)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AttestationObject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CredentialProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProofKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VerificationMethod)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProofPurpose)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CredentialStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StatusKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VerificationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethodKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethodKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyJwk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyJwk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyMultibase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyMultibase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBase58", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBase58 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyBase64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyBase64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyPem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyPem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyHex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyHex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebauthnCredential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebauthnCredential == nil {
				m.WebauthnCredential = &WebAuthnCredential{}
			}
			if err := m.WebauthnCredential.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockchainAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockchainAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerificationMethodReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerificationMethodReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerificationMethodReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethodId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethodId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbeddedVerificationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmbeddedVerificationMethod == nil {
				m.EmbeddedVerificationMethod = &VerificationMethod{}
			}
			if err := m.EmbeddedVerificationMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultipleEndpoints == nil {
				m.MultipleEndpoints = &ServiceEndpoints{}
			}
			if err := m.MultipleEndpoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplexEndpoint", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComplexEndpoint = append(m.ComplexEndpoint[:0], dAtA[iNdEx:postIndex]...)
			if m.ComplexEndpoint == nil {
				m.ComplexEndpoint = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceEndpoints) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceEndpoints: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceEndpoints: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebAuthnCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebAuthnCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebAuthnCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transports = append(m.Transports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserVerified = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureAlgorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientDataJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientDataJson = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationObject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofPurpose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofPurpose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
