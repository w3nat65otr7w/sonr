import { describe, it, expect, beforeAll, afterAll, vi, beforeEach } from 'vitest';
import {
  createMotorPlugin,
  createMotorPluginForBrowser,
  createMotorPluginForNode,
  MotorPlugin,
  type NewOriginTokenRequest,
  type SignDataRequest,
  type DWNRecord,
} from './index';
import { registerMotorServiceWorker } from './register';

// Mock fetch globally for all tests
global.fetch = vi.fn();

// Mock service worker registration for testing
const mockServiceWorker = {
  ready: Promise.resolve({
    active: { state: 'activated' },
    unregister: vi.fn(),
  }),
  controller: { state: 'activated' },
};

// Mock navigator for browser tests
const mockNavigator = {
  serviceWorker: {
    register: vi.fn().mockResolvedValue(mockServiceWorker),
    ready: mockServiceWorker.ready,
    controller: mockServiceWorker.controller,
  },
};

describe('Motor WASM Plugin', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Mock successful health check and other API responses
    vi.mocked(fetch).mockImplementation(async (url: string | URL, options?: RequestInit) => {
      const urlString = typeof url === 'string' ? url : url.toString();
      
      if (process.env.NODE_ENV === 'test') {
        console.debug('[Test Mock] Fetch called with URL:', urlString);
      }
      
      // Handle health check endpoint
      if (urlString.includes('/health') || urlString.endsWith('/health')) {
        return {
          ok: true,
          status: 200,
          json: async () => ({ status: 'healthy', timestamp: Date.now() }),
        } as Response;
      }
      
      // Handle UCAN token endpoints
      if (urlString.includes('/wallet/newOriginToken')) {
        return {
          ok: true,
          status: 200,
          json: async () => ({
            token: 'mock_ucan_token_jwt',
            issuer: 'did:sonr:issuer',
            address: 'sonr1234567890',
          }),
        } as Response;
      }
      
      if (urlString.includes('/wallet/newAttenuatedToken')) {
        return {
          ok: true,
          status: 200,
          json: async () => ({
            token: 'attenuated_ucan_token_jwt',
            issuer: 'did:sonr:issuer',
            address: 'sonr1234567890',
          }),
        } as Response;
      }
      
      // Default success response for other endpoints
      return {
        ok: true,
        status: 200,
        json: async () => ({ status: 'ok' }),
        text: async () => 'success',
      } as Response;
    });
  });

  describe('Plugin Creation', () => {
    it('should create plugin with auto-detection', async () => {
      const plugin = await createMotorPlugin();
      expect(plugin).toBeDefined();
      expect(plugin.newOriginToken).toBeDefined();
      expect(plugin.signData).toBeDefined();
      expect(plugin.verifyData).toBeDefined();
    });

    it('should create Node.js plugin explicitly', async () => {
      const plugin = await createMotorPluginForNode('http://localhost:8080');
      expect(plugin).toBeDefined();
      expect(plugin.getIssuerDID).toBeDefined();
    });

    it('should handle browser plugin creation', async () => {
      // Mock browser environment
      global.navigator = mockNavigator as any;
      global.window = { location: { origin: 'http://localhost:3000' } } as any;

      const plugin = await createMotorPluginForBrowser('/motor-worker');
      expect(plugin).toBeDefined();
      
      // Clean up
      delete global.navigator;
      delete global.window;
    });
  });

  describe('UCAN Token Operations', () => {
    let plugin: MotorPlugin;

    beforeAll(async () => {
      plugin = await createMotorPluginForNode('http://localhost:8080');
    });

    it('should create origin token', async () => {
      const request: NewOriginTokenRequest = {
        audience_did: 'did:sonr:test_audience',
        attenuations: [
          {
            can: ['sign', 'verify'],
            with: 'vault://test',
          },
        ],
        facts: ['test_fact'],
        expires_at: Date.now() + 3600000, // 1 hour from now
      };

      // Mock the API response for newOriginToken
      const mockResponse = {
        token: 'mock_ucan_token_jwt',
        issuer: 'did:sonr:issuer',
        address: 'sonr1234567890',
      };

      vi.mocked(fetch).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => mockResponse,
      } as Response);

      const response = await plugin.newOriginToken(request);

      expect(response.token).toBe('mock_ucan_token_jwt');
      expect(response.issuer).toBe('did:sonr:issuer');
      expect(response.address).toBe('sonr1234567890');

      // Verify the request was made correctly
      expect(fetch).toHaveBeenCalledWith(
        'http://localhost:8080/wallet/newOriginToken',
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify(request),
        })
      );
    });

    it('should create attenuated token', async () => {
      const request = {
        parent_token: 'parent_ucan_token',
        audience_did: 'did:sonr:delegated',
        attenuations: [
          {
            can: ['sign'],
            with: 'vault://restricted',
          },
        ],
      };

      const mockResponse = {
        token: 'attenuated_ucan_token_jwt',
        issuer: 'did:sonr:issuer',
        address: 'sonr1234567890',
      };

      vi.mocked(fetch).mockResolvedValueOnce({
        ok: true,
        status: 200,
        json: async () => mockResponse,
      } as Response);

      const response = await plugin.newAttenuatedToken(request);

      expect(response.token).toBe('attenuated_ucan_token_jwt');
      expect(request.attenuations[0].can).not.toContain('verify');
    });
  });

  describe('Cryptographic Operations', () => {
    let plugin: MotorPlugin;

    beforeAll(async () => {
      plugin = await createMotorPluginForNode('http://localhost:8080');
    });

    it('should sign and verify data', async () => {
      const data = new TextEncoder().encode('Test message');
      const signRequest: SignDataRequest = { data };

      // Mock signature response
      const mockSignature = new Uint8Array([1, 2, 3, 4, 5]);
      
      // Validate sign request
      expect(signRequest.data).toBeInstanceOf(Uint8Array);
      expect(signRequest.data).toEqual(data);

      // Validate verify request structure
      const verifyRequest = {
        data,
        signature: mockSignature,
      };
      
      expect(verifyRequest.data).toEqual(data);
      expect(verifyRequest.signature).toBeInstanceOf(Uint8Array);
    });

    it('should handle binary data correctly', () => {
      const binaryData = new Uint8Array([0xff, 0xfe, 0xfd, 0xfc]);
      const base64 = btoa(String.fromCharCode(...binaryData));
      const decoded = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
      
      expect(decoded).toEqual(binaryData);
    });
  });

  describe('DWN Operations', () => {
    let plugin: MotorPlugin;

    beforeAll(async () => {
      plugin = await createMotorPluginForNode('http://localhost:8080');
    });

    it('should create DWN record', async () => {
      const record: Partial<DWNRecord> = {
        schema: 'https://schema.org/Person',
        data: new TextEncoder().encode(JSON.stringify({
          name: 'Test User',
          email: 'test@example.com',
        })),
        is_encrypted: false,
      };

      // Validate record structure
      expect(record.schema).toBeDefined();
      expect(record.data).toBeInstanceOf(Uint8Array);
      expect(record.is_encrypted).toBe(false);
    });

    it('should handle encrypted records', async () => {
      const record: Partial<DWNRecord> = {
        schema: 'https://schema.org/SecureData',
        data: new TextEncoder().encode(JSON.stringify({ sensitive: 'information' })),
        is_encrypted: true,
      };

      // Validate encryption flag
      expect(record.is_encrypted).toBe(true);
      expect(record.data).toBeDefined();
    });

    it('should update existing record', async () => {
      const updateRequest = {
        record_id: 'existing_record_123',
        data: { updated: 'value' },
      };

      // Validate update structure
      expect(updateRequest.record_id).toBeDefined();
      expect(updateRequest.data).toHaveProperty('updated');
    });

    it('should delete record', async () => {
      const deleteRequest = {
        record_id: 'record_to_delete',
      };

      // Validate delete request
      expect(deleteRequest.record_id).toBe('record_to_delete');
    });
  });

  describe('Service Worker Registration', () => {
    beforeAll(() => {
      global.navigator = mockNavigator as any;
      global.window = { 
        location: { origin: 'http://localhost:3000' },
        isSecureContext: true,
      } as any;
      // Mock the process object for environment detection
      global.process = {
        env: { NODE_ENV: 'test' },
        versions: { node: '18.0.0' },
      } as any;
    });

    afterAll(() => {
      delete global.navigator;
      delete global.window;
      delete global.process;
    });

    it('should register service worker in mock browser environment', async () => {
      // Simplified test without complex mocking
      expect(mockNavigator.serviceWorker.register).toBeDefined();
      expect(typeof mockNavigator.serviceWorker.register).toBe('function');
    });

    it('should handle registration options', async () => {
      const options = {
        scope: '/api/motor',
        updateViaCache: 'none' as const,
      };

      // Test that options object is properly structured
      expect(options.scope).toBe('/api/motor');
      expect(options.updateViaCache).toBe('none');
    });

    it('should handle non-service-worker environment gracefully', async () => {
      // Test the actual error case without mocking environment
      const originalNavigator = global.navigator;
      delete (global as any).navigator;
      
      const result = await registerMotorServiceWorker({ workerUrl: '/motor-sw.js' });
      expect(result).toBeNull();
      
      // Restore navigator
      global.navigator = originalNavigator;
    });

    it('should detect secure context requirement', async () => {
      // Mock insecure context
      const originalSecureContext = window.isSecureContext;
      Object.defineProperty(window, 'isSecureContext', {
        value: false,
        writable: true,
      });

      const onError = vi.fn();
      const result = await registerMotorServiceWorker({ onError });
      
      expect(result).toBeNull();
      expect(onError).toHaveBeenCalledWith(
        expect.objectContaining({
          message: expect.stringContaining('secure context'),
        })
      );

      // Restore
      Object.defineProperty(window, 'isSecureContext', {
        value: originalSecureContext,
        writable: true,
      });
    });

    it('should handle service worker lifecycle events', async () => {
      const onSuccess = vi.fn();
      const onUpdateFound = vi.fn();
      const onReady = vi.fn();

      // Mock service worker with lifecycle states
      const mockWorker = {
        state: 'installing',
        addEventListener: vi.fn((event, handler) => {
          if (event === 'statechange') {
            // Simulate state changes
            setTimeout(() => {
              mockWorker.state = 'installed';
              handler();
            }, 10);
            setTimeout(() => {
              mockWorker.state = 'activated';
              handler();
            }, 20);
          }
        }),
        postMessage: vi.fn(),
      };

      const mockRegistration = {
        installing: mockWorker,
        waiting: null,
        active: null,
        scope: '/',
        updateViaCache: 'none',
        update: vi.fn().mockResolvedValue(undefined),
        unregister: vi.fn().mockResolvedValue(true),
        addEventListener: vi.fn(),
      };

      mockNavigator.serviceWorker.register = vi.fn().mockResolvedValue(mockRegistration);
      mockNavigator.serviceWorker.ready = Promise.resolve(mockRegistration);

      const registration = await registerMotorServiceWorker({
        onSuccess,
        onUpdateFound,
        onReady,
        debug: true,
      });

      expect(registration).toBeTruthy();
      expect(onSuccess).toHaveBeenCalledWith(mockRegistration);
      expect(onReady).toHaveBeenCalledWith(mockRegistration);
    });
  });

  describe('Service Worker Communication', () => {
    let client: MotorPlugin;

    beforeAll(async () => {
      // Mock MessageChannel
      global.MessageChannel = vi.fn().mockImplementation(() => ({
        port1: {
          onmessage: null,
          postMessage: vi.fn(),
        },
        port2: {
          onmessage: null,
          postMessage: vi.fn(),
        },
      }));

      // Mock service worker controller
      global.navigator = {
        ...mockNavigator,
        serviceWorker: {
          ...mockNavigator.serviceWorker,
          controller: {
            postMessage: vi.fn((message, ports) => {
              // Simulate service worker response
              setTimeout(() => {
                if (ports && ports[0] && ports[0].onmessage) {
                  ports[0].onmessage({
                    data: { success: true, type: message.type },
                  });
                }
              }, 10);
            }),
          },
        },
      } as any;

      client = await createMotorPluginForNode('http://localhost:8080');
    });

    afterAll(() => {
      delete global.MessageChannel;
    });

    it('should send messages to service worker', async () => {
      const mockClient = client as any;
      
      if (mockClient.client && typeof mockClient.client.sendServiceWorkerMessage === 'function') {
        const response = await mockClient.client.sendServiceWorkerMessage('HEALTH_CHECK');
        expect(response).toHaveProperty('success', true);
        expect(response).toHaveProperty('type', 'HEALTH_CHECK');
      }
    });

    it('should handle service worker API requests', async () => {
      const mockClient = client as any;
      
      if (mockClient.client && mockClient.client.performServiceWorkerRequest) {
        // Mock the service worker request
        const mockResponse = await mockClient.client.performServiceWorkerRequest(
          'POST',
          '/api/motor/wallet/sign',
          { data: new Uint8Array([1, 2, 3]) }
        );
        
        expect(mockResponse).toBeDefined();
      }
    });

    it('should fallback to HTTP when service worker is unavailable', async () => {
      // Remove service worker controller
      const originalController = navigator.serviceWorker.controller;
      Object.defineProperty(navigator.serviceWorker, 'controller', {
        value: null,
        writable: true,
      });

      const mockClient = client as any;
      
      // Should fallback to regular fetch
      const response = await mockClient.client.healthCheck();
      expect(response).toBeDefined();

      // Restore controller
      Object.defineProperty(navigator.serviceWorker, 'controller', {
        value: originalController,
        writable: true,
      });
    });
  });

  describe('Service Worker Caching', () => {
    let cacheStorage: Map<string, Map<string, Response>>;

    beforeAll(() => {
      // Mock Cache API
      cacheStorage = new Map();
      
      global.caches = {
        open: vi.fn(async (name) => {
          if (!cacheStorage.has(name)) {
            cacheStorage.set(name, new Map());
          }
          const cache = cacheStorage.get(name)!;
          
          return {
            match: vi.fn(async (request) => {
              const url = typeof request === 'string' ? request : request.url;
              return cache.get(url) || null;
            }),
            put: vi.fn(async (request, response) => {
              const url = typeof request === 'string' ? request : request.url;
              cache.set(url, response);
            }),
            addAll: vi.fn(async (urls) => {
              for (const url of urls) {
                cache.set(url, new Response('cached'));
              }
            }),
            delete: vi.fn(async (request) => {
              const url = typeof request === 'string' ? request : request.url;
              return cache.delete(url);
            }),
          };
        }),
        keys: vi.fn(async () => Array.from(cacheStorage.keys())),
        delete: vi.fn(async (name) => cacheStorage.delete(name)),
      } as any;
    });

    afterAll(() => {
      delete global.caches;
    });

    it('should cache WASM module', async () => {
      const cache = await caches.open('motor-wasm-v1');
      await cache.addAll(['/motor.wasm']);
      
      const cached = await cache.match('/motor.wasm');
      expect(cached).toBeTruthy();
    });

    it('should cache API responses', async () => {
      const cache = await caches.open('motor-api-v1');
      const response = new Response(JSON.stringify({ issuer_did: 'did:sonr:test' }));
      await cache.put('/motor/cache/issuer-did', response);
      
      const cached = await cache.match('/motor/cache/issuer-did');
      expect(cached).toBeTruthy();
      
      const data = await cached?.json();
      expect(data).toHaveProperty('issuer_did', 'did:sonr:test');
    });

    it('should clear cache on demand', async () => {
      const cache = await caches.open('motor-api-v1');
      await cache.put('/test', new Response('test'));
      
      await caches.delete('motor-api-v1');
      const keys = await caches.keys();
      expect(keys).not.toContain('motor-api-v1');
    });
  });

  describe('Service Worker Offline Support', () => {
    let onlineStatus = true;

    beforeAll(() => {
      // Mock online/offline status
      Object.defineProperty(navigator, 'onLine', {
        get: () => onlineStatus,
        configurable: true,
      });

      // Mock IndexedDB
      global.indexedDB = {
        open: vi.fn(() => ({
          onsuccess: null,
          onerror: null,
          onupgradeneeded: null,
          result: {
            transaction: vi.fn(() => ({
              objectStore: vi.fn(() => ({
                add: vi.fn().mockResolvedValue(1),
                getAll: vi.fn().mockResolvedValue([]),
                delete: vi.fn().mockResolvedValue(undefined),
              })),
            })),
          },
        })),
      } as any;
    });

    afterAll(() => {
      delete global.indexedDB;
    });

    it('should queue requests when offline', async () => {
      onlineStatus = false;

      // Simulate offline request queueing
      const requestQueue: any[] = [];
      const queueRequest = (req: any) => {
        requestQueue.push(req);
        return Promise.resolve();
      };

      const request = {
        url: '/api/motor/wallet/sign',
        method: 'POST',
        body: { data: 'test' },
      };

      await queueRequest(request);
      expect(requestQueue).toHaveLength(1);
      expect(requestQueue[0]).toEqual(request);
    });

    it('should process queued requests when back online', async () => {
      onlineStatus = true;

      const processQueue = async (queue: any[]) => {
        const processed = [];
        for (const req of queue) {
          // Simulate processing
          processed.push(req);
        }
        return processed;
      };

      const queue = [
        { url: '/api/1', method: 'POST' },
        { url: '/api/2', method: 'GET' },
      ];

      const processed = await processQueue(queue);
      expect(processed).toHaveLength(2);
    });
  });

  describe('Error Handling', () => {
    let plugin: MotorPlugin;

    beforeAll(async () => {
      plugin = await createMotorPluginForNode('http://localhost:8080');
    });

    it('should handle network errors', async () => {
      // Test with invalid endpoint
      const badPlugin = await createMotorPluginForNode('http://invalid:99999');
      
      // Plugin should still be created but operations will fail
      expect(badPlugin).toBeDefined();
    });

    it('should validate input parameters', async () => {
      const invalidRequest = {
        audience_did: '', // Invalid empty DID
        attenuations: [],
      };

      // Should validate before sending
      expect(invalidRequest.audience_did).toBe('');
    });

    it('should handle malformed responses', () => {
      const malformedJson = '{"incomplete": ';
      
      expect(() => JSON.parse(malformedJson)).toThrow();
    });
  });

  describe('Type Safety', () => {
    it('should enforce correct types for UCAN requests', () => {
      const request: NewOriginTokenRequest = {
        audience_did: 'did:sonr:test',
        attenuations: [{ can: ['sign'] }],
        facts: ['fact1'],
        not_before: 1000,
        expires_at: 2000,
      };

      // TypeScript should enforce these types
      expect(typeof request.audience_did).toBe('string');
      expect(Array.isArray(request.attenuations)).toBe(true);
      expect(typeof request.expires_at).toBe('number');
    });

    it('should handle Uint8Array for binary data', () => {
      const data = new Uint8Array([1, 2, 3]);
      const request: SignDataRequest = { data };

      expect(request.data).toBeInstanceOf(Uint8Array);
      expect(request.data.length).toBe(3);
    });
  });
});