// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file svc/v1/genesis.proto (package svc.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { ServiceCapability } from "./state_pb.js";
import { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";

/**
 * GenesisState defines the module genesis state
 *
 * @generated from message svc.v1.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * Params defines all the parameters of the module.
   *
   * @generated from field: svc.v1.Params params = 1;
   */
  params?: Params;

  /**
   * Service capabilities stored in the module
   *
   * @generated from field: repeated svc.v1.ServiceCapability capabilities = 2;
   */
  capabilities: ServiceCapability[] = [];

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "svc.v1.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
    { no: 2, name: "capabilities", kind: "message", T: ServiceCapability, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

/**
 * Params defines the set of module parameters.
 *
 * @generated from message svc.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * Service Limits
   * Maximum number of services that can be registered per account
   *
   * @generated from field: uint32 max_services_per_account = 1;
   */
  maxServicesPerAccount = 0;

  /**
   * Maximum number of domains that can be bound to a single service
   *
   * @generated from field: uint32 max_domains_per_service = 2;
   */
  maxDomainsPerService = 0;

  /**
   * Maximum number of endpoints that can be registered per service
   *
   * @generated from field: uint32 max_endpoints_per_service = 3;
   */
  maxEndpointsPerService = 0;

  /**
   * Timeouts and Intervals (in seconds)
   * Time allowed for domain ownership verification before expiry
   *
   * @generated from field: int64 domain_verification_timeout = 4;
   */
  domainVerificationTimeout = protoInt64.zero;

  /**
   * Interval between service health checks
   *
   * @generated from field: int64 service_health_check_interval = 5;
   */
  serviceHealthCheckInterval = protoInt64.zero;

  /**
   * Default expiration time for capabilities if not specified
   *
   * @generated from field: int64 capability_default_expiration = 6;
   */
  capabilityDefaultExpiration = protoInt64.zero;

  /**
   * Economic Parameters
   * Fee required to register a new service
   *
   * @generated from field: cosmos.base.v1beta1.Coin service_registration_fee = 7;
   */
  serviceRegistrationFee?: Coin;

  /**
   * Fee required to verify domain ownership
   *
   * @generated from field: cosmos.base.v1beta1.Coin domain_verification_fee = 8;
   */
  domainVerificationFee?: Coin;

  /**
   * Minimum stake required to keep a service active
   *
   * @generated from field: cosmos.base.v1beta1.Coin min_service_stake = 9;
   */
  minServiceStake?: Coin;

  /**
   * UCAN and Capability Settings
   * Maximum depth of delegation chains for capabilities
   *
   * @generated from field: uint32 max_delegation_chain_depth = 10;
   */
  maxDelegationChainDepth = 0;

  /**
   * Maximum lifetime for UCAN tokens (in seconds)
   *
   * @generated from field: int64 ucan_max_lifetime = 11;
   */
  ucanMaxLifetime = protoInt64.zero;

  /**
   * Minimum lifetime for UCAN tokens (in seconds)
   *
   * @generated from field: int64 ucan_min_lifetime = 12;
   */
  ucanMinLifetime = protoInt64.zero;

  /**
   * List of supported signature algorithms for UCAN
   *
   * @generated from field: repeated string supported_signature_algorithms = 13;
   */
  supportedSignatureAlgorithms: string[] = [];

  /**
   * Validation Rules
   * Whether to require cryptographic proof of domain ownership
   *
   * @generated from field: bool require_domain_ownership_proof = 14;
   */
  requireDomainOwnershipProof = false;

  /**
   * Whether to require HTTPS for service endpoints
   *
   * @generated from field: bool require_https = 15;
   */
  requireHttps = false;

  /**
   * Whether to allow localhost domains for development
   *
   * @generated from field: bool allow_localhost = 16;
   */
  allowLocalhost = false;

  /**
   * Maximum length for service description text
   *
   * @generated from field: uint32 max_service_description_length = 17;
   */
  maxServiceDescriptionLength = 0;

  /**
   * Rate Limiting
   * Maximum number of service registrations allowed per block
   *
   * @generated from field: uint32 max_registrations_per_block = 18;
   */
  maxRegistrationsPerBlock = 0;

  /**
   * Maximum number of service updates allowed per block
   *
   * @generated from field: uint32 max_updates_per_block = 19;
   */
  maxUpdatesPerBlock = 0;

  /**
   * Maximum number of capability grants allowed per block
   *
   * @generated from field: uint32 max_capability_grants_per_block = 20;
   */
  maxCapabilityGrantsPerBlock = 0;

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "svc.v1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_services_per_account", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "max_domains_per_service", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "max_endpoints_per_service", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "domain_verification_timeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "service_health_check_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "capability_default_expiration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "service_registration_fee", kind: "message", T: Coin },
    { no: 8, name: "domain_verification_fee", kind: "message", T: Coin },
    { no: 9, name: "min_service_stake", kind: "message", T: Coin },
    { no: 10, name: "max_delegation_chain_depth", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "ucan_max_lifetime", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "ucan_min_lifetime", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 13, name: "supported_signature_algorithms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "require_domain_ownership_proof", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "require_https", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "allow_localhost", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "max_service_description_length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 18, name: "max_registrations_per_block", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 19, name: "max_updates_per_block", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 20, name: "max_capability_grants_per_block", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

