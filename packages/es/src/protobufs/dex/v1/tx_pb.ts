// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file dex/v1/tx.proto (package dex.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";

/**
 * MsgRegisterDEXAccount registers a new ICA account for DEX operations
 *
 * @generated from message dex.v1.MsgRegisterDEXAccount
 */
export class MsgRegisterDEXAccount extends Message<MsgRegisterDEXAccount> {
  /**
   * DID controller requesting the account
   *
   * @generated from field: string did = 1;
   */
  did = "";

  /**
   * IBC connection to target chain
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * Requested features for this account
   *
   * @generated from field: repeated string features = 3;
   */
  features: string[] = [];

  /**
   * Optional metadata
   *
   * @generated from field: string metadata = 4;
   */
  metadata = "";

  constructor(data?: PartialMessage<MsgRegisterDEXAccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgRegisterDEXAccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "did", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterDEXAccount {
    return new MsgRegisterDEXAccount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterDEXAccount {
    return new MsgRegisterDEXAccount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterDEXAccount {
    return new MsgRegisterDEXAccount().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRegisterDEXAccount | PlainMessage<MsgRegisterDEXAccount> | undefined, b: MsgRegisterDEXAccount | PlainMessage<MsgRegisterDEXAccount> | undefined): boolean {
    return proto3.util.equals(MsgRegisterDEXAccount, a, b);
  }
}

/**
 * MsgRegisterDEXAccountResponse defines the response
 *
 * @generated from message dex.v1.MsgRegisterDEXAccountResponse
 */
export class MsgRegisterDEXAccountResponse extends Message<MsgRegisterDEXAccountResponse> {
  /**
   * Generated port ID for the account
   *
   * @generated from field: string port_id = 1;
   */
  portId = "";

  /**
   * Account address on remote chain (once available)
   *
   * @generated from field: string account_address = 2;
   */
  accountAddress = "";

  constructor(data?: PartialMessage<MsgRegisterDEXAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgRegisterDEXAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterDEXAccountResponse {
    return new MsgRegisterDEXAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterDEXAccountResponse {
    return new MsgRegisterDEXAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterDEXAccountResponse {
    return new MsgRegisterDEXAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRegisterDEXAccountResponse | PlainMessage<MsgRegisterDEXAccountResponse> | undefined, b: MsgRegisterDEXAccountResponse | PlainMessage<MsgRegisterDEXAccountResponse> | undefined): boolean {
    return proto3.util.equals(MsgRegisterDEXAccountResponse, a, b);
  }
}

/**
 * MsgExecuteSwap executes a token swap on a remote chain
 *
 * @generated from message dex.v1.MsgExecuteSwap
 */
export class MsgExecuteSwap extends Message<MsgExecuteSwap> {
  /**
   * DID initiating the swap
   *
   * @generated from field: string did = 1;
   */
  did = "";

  /**
   * IBC connection to DEX chain
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * Token to swap from
   *
   * @generated from field: string source_denom = 3;
   */
  sourceDenom = "";

  /**
   * Token to swap to
   *
   * @generated from field: string target_denom = 4;
   */
  targetDenom = "";

  /**
   * Amount to swap
   *
   * @generated from field: string amount = 5;
   */
  amount = "";

  /**
   * Minimum amount out (slippage protection)
   *
   * @generated from field: string min_amount_out = 6;
   */
  minAmountOut = "";

  /**
   * Optional specific route
   *
   * @generated from field: string route = 7;
   */
  route = "";

  /**
   * UCAN authorization token
   *
   * @generated from field: string ucan_token = 8;
   */
  ucanToken = "";

  /**
   * Timeout for the swap
   *
   * @generated from field: google.protobuf.Timestamp timeout = 9;
   */
  timeout?: Timestamp;

  constructor(data?: PartialMessage<MsgExecuteSwap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgExecuteSwap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "did", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "source_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "target_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "min_amount_out", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "route", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "ucan_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "timeout", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgExecuteSwap {
    return new MsgExecuteSwap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgExecuteSwap {
    return new MsgExecuteSwap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgExecuteSwap {
    return new MsgExecuteSwap().fromJsonString(jsonString, options);
  }

  static equals(a: MsgExecuteSwap | PlainMessage<MsgExecuteSwap> | undefined, b: MsgExecuteSwap | PlainMessage<MsgExecuteSwap> | undefined): boolean {
    return proto3.util.equals(MsgExecuteSwap, a, b);
  }
}

/**
 * MsgExecuteSwapResponse defines the response
 *
 * @generated from message dex.v1.MsgExecuteSwapResponse
 */
export class MsgExecuteSwapResponse extends Message<MsgExecuteSwapResponse> {
  /**
   * Transaction ID on remote chain
   *
   * @generated from field: string tx_hash = 1;
   */
  txHash = "";

  /**
   * Actual amount received
   *
   * @generated from field: string amount_received = 2;
   */
  amountReceived = "";

  /**
   * IBC packet sequence
   *
   * @generated from field: uint64 sequence = 3;
   */
  sequence = protoInt64.zero;

  constructor(data?: PartialMessage<MsgExecuteSwapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgExecuteSwapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount_received", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgExecuteSwapResponse {
    return new MsgExecuteSwapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgExecuteSwapResponse {
    return new MsgExecuteSwapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgExecuteSwapResponse {
    return new MsgExecuteSwapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgExecuteSwapResponse | PlainMessage<MsgExecuteSwapResponse> | undefined, b: MsgExecuteSwapResponse | PlainMessage<MsgExecuteSwapResponse> | undefined): boolean {
    return proto3.util.equals(MsgExecuteSwapResponse, a, b);
  }
}

/**
 * MsgProvideLiquidity adds liquidity to a pool
 *
 * @generated from message dex.v1.MsgProvideLiquidity
 */
export class MsgProvideLiquidity extends Message<MsgProvideLiquidity> {
  /**
   * DID providing liquidity
   *
   * @generated from field: string did = 1;
   */
  did = "";

  /**
   * IBC connection to DEX chain
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * Pool ID to add liquidity to
   *
   * @generated from field: string pool_id = 3;
   */
  poolId = "";

  /**
   * Assets to provide
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin assets = 4;
   */
  assets: Coin[] = [];

  /**
   * Minimum shares to receive (slippage protection)
   *
   * @generated from field: string min_shares = 5;
   */
  minShares = "";

  /**
   * UCAN authorization token
   *
   * @generated from field: string ucan_token = 6;
   */
  ucanToken = "";

  /**
   * Timeout for the operation
   *
   * @generated from field: google.protobuf.Timestamp timeout = 7;
   */
  timeout?: Timestamp;

  constructor(data?: PartialMessage<MsgProvideLiquidity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgProvideLiquidity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "did", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "assets", kind: "message", T: Coin, repeated: true },
    { no: 5, name: "min_shares", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ucan_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "timeout", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgProvideLiquidity {
    return new MsgProvideLiquidity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgProvideLiquidity {
    return new MsgProvideLiquidity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgProvideLiquidity {
    return new MsgProvideLiquidity().fromJsonString(jsonString, options);
  }

  static equals(a: MsgProvideLiquidity | PlainMessage<MsgProvideLiquidity> | undefined, b: MsgProvideLiquidity | PlainMessage<MsgProvideLiquidity> | undefined): boolean {
    return proto3.util.equals(MsgProvideLiquidity, a, b);
  }
}

/**
 * MsgProvideLiquidityResponse defines the response
 *
 * @generated from message dex.v1.MsgProvideLiquidityResponse
 */
export class MsgProvideLiquidityResponse extends Message<MsgProvideLiquidityResponse> {
  /**
   * Transaction ID on remote chain
   *
   * @generated from field: string tx_hash = 1;
   */
  txHash = "";

  /**
   * LP tokens received
   *
   * @generated from field: string shares_received = 2;
   */
  sharesReceived = "";

  /**
   * IBC packet sequence
   *
   * @generated from field: uint64 sequence = 3;
   */
  sequence = protoInt64.zero;

  constructor(data?: PartialMessage<MsgProvideLiquidityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgProvideLiquidityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shares_received", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgProvideLiquidityResponse {
    return new MsgProvideLiquidityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgProvideLiquidityResponse {
    return new MsgProvideLiquidityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgProvideLiquidityResponse {
    return new MsgProvideLiquidityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgProvideLiquidityResponse | PlainMessage<MsgProvideLiquidityResponse> | undefined, b: MsgProvideLiquidityResponse | PlainMessage<MsgProvideLiquidityResponse> | undefined): boolean {
    return proto3.util.equals(MsgProvideLiquidityResponse, a, b);
  }
}

/**
 * MsgRemoveLiquidity removes liquidity from a pool
 *
 * @generated from message dex.v1.MsgRemoveLiquidity
 */
export class MsgRemoveLiquidity extends Message<MsgRemoveLiquidity> {
  /**
   * DID removing liquidity
   *
   * @generated from field: string did = 1;
   */
  did = "";

  /**
   * IBC connection to DEX chain
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * Pool ID to remove liquidity from
   *
   * @generated from field: string pool_id = 3;
   */
  poolId = "";

  /**
   * Amount of shares to remove
   *
   * @generated from field: string shares = 4;
   */
  shares = "";

  /**
   * Minimum assets to receive
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin min_amounts = 5;
   */
  minAmounts: Coin[] = [];

  /**
   * UCAN authorization token
   *
   * @generated from field: string ucan_token = 6;
   */
  ucanToken = "";

  /**
   * Timeout for the operation
   *
   * @generated from field: google.protobuf.Timestamp timeout = 7;
   */
  timeout?: Timestamp;

  constructor(data?: PartialMessage<MsgRemoveLiquidity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgRemoveLiquidity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "did", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "shares", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "min_amounts", kind: "message", T: Coin, repeated: true },
    { no: 6, name: "ucan_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "timeout", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRemoveLiquidity {
    return new MsgRemoveLiquidity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRemoveLiquidity {
    return new MsgRemoveLiquidity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRemoveLiquidity {
    return new MsgRemoveLiquidity().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRemoveLiquidity | PlainMessage<MsgRemoveLiquidity> | undefined, b: MsgRemoveLiquidity | PlainMessage<MsgRemoveLiquidity> | undefined): boolean {
    return proto3.util.equals(MsgRemoveLiquidity, a, b);
  }
}

/**
 * MsgRemoveLiquidityResponse defines the response
 *
 * @generated from message dex.v1.MsgRemoveLiquidityResponse
 */
export class MsgRemoveLiquidityResponse extends Message<MsgRemoveLiquidityResponse> {
  /**
   * Transaction ID on remote chain
   *
   * @generated from field: string tx_hash = 1;
   */
  txHash = "";

  /**
   * Assets received
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin assets_received = 2;
   */
  assetsReceived: Coin[] = [];

  /**
   * IBC packet sequence
   *
   * @generated from field: uint64 sequence = 3;
   */
  sequence = protoInt64.zero;

  constructor(data?: PartialMessage<MsgRemoveLiquidityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgRemoveLiquidityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "assets_received", kind: "message", T: Coin, repeated: true },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRemoveLiquidityResponse {
    return new MsgRemoveLiquidityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRemoveLiquidityResponse {
    return new MsgRemoveLiquidityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRemoveLiquidityResponse {
    return new MsgRemoveLiquidityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRemoveLiquidityResponse | PlainMessage<MsgRemoveLiquidityResponse> | undefined, b: MsgRemoveLiquidityResponse | PlainMessage<MsgRemoveLiquidityResponse> | undefined): boolean {
    return proto3.util.equals(MsgRemoveLiquidityResponse, a, b);
  }
}

/**
 * MsgCreateLimitOrder creates a limit order
 *
 * @generated from message dex.v1.MsgCreateLimitOrder
 */
export class MsgCreateLimitOrder extends Message<MsgCreateLimitOrder> {
  /**
   * DID creating the order
   *
   * @generated from field: string did = 1;
   */
  did = "";

  /**
   * IBC connection to DEX chain
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * Token to sell
   *
   * @generated from field: string sell_denom = 3;
   */
  sellDenom = "";

  /**
   * Token to buy
   *
   * @generated from field: string buy_denom = 4;
   */
  buyDenom = "";

  /**
   * Amount to sell
   *
   * @generated from field: string amount = 5;
   */
  amount = "";

  /**
   * Price per unit
   *
   * @generated from field: string price = 6;
   */
  price = "";

  /**
   * Order expiration
   *
   * @generated from field: google.protobuf.Timestamp expiration = 7;
   */
  expiration?: Timestamp;

  /**
   * UCAN authorization token
   *
   * @generated from field: string ucan_token = 8;
   */
  ucanToken = "";

  constructor(data?: PartialMessage<MsgCreateLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgCreateLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "did", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sell_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "buy_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "expiration", kind: "message", T: Timestamp },
    { no: 8, name: "ucan_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateLimitOrder {
    return new MsgCreateLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateLimitOrder {
    return new MsgCreateLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateLimitOrder {
    return new MsgCreateLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateLimitOrder | PlainMessage<MsgCreateLimitOrder> | undefined, b: MsgCreateLimitOrder | PlainMessage<MsgCreateLimitOrder> | undefined): boolean {
    return proto3.util.equals(MsgCreateLimitOrder, a, b);
  }
}

/**
 * MsgCreateLimitOrderResponse defines the response
 *
 * @generated from message dex.v1.MsgCreateLimitOrderResponse
 */
export class MsgCreateLimitOrderResponse extends Message<MsgCreateLimitOrderResponse> {
  /**
   * Order ID on remote chain
   *
   * @generated from field: string order_id = 1;
   */
  orderId = "";

  /**
   * Transaction ID
   *
   * @generated from field: string tx_hash = 2;
   */
  txHash = "";

  /**
   * IBC packet sequence
   *
   * @generated from field: uint64 sequence = 3;
   */
  sequence = protoInt64.zero;

  constructor(data?: PartialMessage<MsgCreateLimitOrderResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgCreateLimitOrderResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateLimitOrderResponse {
    return new MsgCreateLimitOrderResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateLimitOrderResponse {
    return new MsgCreateLimitOrderResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateLimitOrderResponse {
    return new MsgCreateLimitOrderResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateLimitOrderResponse | PlainMessage<MsgCreateLimitOrderResponse> | undefined, b: MsgCreateLimitOrderResponse | PlainMessage<MsgCreateLimitOrderResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateLimitOrderResponse, a, b);
  }
}

/**
 * MsgCancelOrder cancels an existing order
 *
 * @generated from message dex.v1.MsgCancelOrder
 */
export class MsgCancelOrder extends Message<MsgCancelOrder> {
  /**
   * DID canceling the order
   *
   * @generated from field: string did = 1;
   */
  did = "";

  /**
   * IBC connection to DEX chain
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * Order ID to cancel
   *
   * @generated from field: string order_id = 3;
   */
  orderId = "";

  /**
   * UCAN authorization token
   *
   * @generated from field: string ucan_token = 4;
   */
  ucanToken = "";

  constructor(data?: PartialMessage<MsgCancelOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgCancelOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "did", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ucan_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCancelOrder {
    return new MsgCancelOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCancelOrder {
    return new MsgCancelOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCancelOrder {
    return new MsgCancelOrder().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCancelOrder | PlainMessage<MsgCancelOrder> | undefined, b: MsgCancelOrder | PlainMessage<MsgCancelOrder> | undefined): boolean {
    return proto3.util.equals(MsgCancelOrder, a, b);
  }
}

/**
 * MsgCancelOrderResponse defines the response
 *
 * @generated from message dex.v1.MsgCancelOrderResponse
 */
export class MsgCancelOrderResponse extends Message<MsgCancelOrderResponse> {
  /**
   * Transaction ID
   *
   * @generated from field: string tx_hash = 1;
   */
  txHash = "";

  /**
   * IBC packet sequence
   *
   * @generated from field: uint64 sequence = 2;
   */
  sequence = protoInt64.zero;

  constructor(data?: PartialMessage<MsgCancelOrderResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dex.v1.MsgCancelOrderResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCancelOrderResponse {
    return new MsgCancelOrderResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCancelOrderResponse {
    return new MsgCancelOrderResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCancelOrderResponse {
    return new MsgCancelOrderResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCancelOrderResponse | PlainMessage<MsgCancelOrderResponse> | undefined, b: MsgCancelOrderResponse | PlainMessage<MsgCancelOrderResponse> | undefined): boolean {
    return proto3.util.equals(MsgCancelOrderResponse, a, b);
  }
}

