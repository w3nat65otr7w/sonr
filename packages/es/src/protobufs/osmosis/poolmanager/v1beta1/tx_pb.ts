// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/poolmanager/v1beta1/tx.proto (package osmosis.poolmanager.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { SwapAmountInRoute, SwapAmountInSplitRoute, SwapAmountOutRoute, SwapAmountOutSplitRoute } from "./swap_route_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * ===================== MsgSwapExactAmountIn
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountIn
 */
export class MsgSwapExactAmountIn extends Message<MsgSwapExactAmountIn> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountInRoute routes = 2;
   */
  routes: SwapAmountInRoute[] = [];

  /**
   * @generated from field: cosmos.base.v1beta1.Coin token_in = 3;
   */
  tokenIn?: Coin;

  /**
   * @generated from field: string token_out_min_amount = 4;
   */
  tokenOutMinAmount = "";

  constructor(data?: PartialMessage<MsgSwapExactAmountIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountInRoute, repeated: true },
    { no: 3, name: "token_in", kind: "message", T: Coin },
    { no: 4, name: "token_out_min_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountIn {
    return new MsgSwapExactAmountIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountIn {
    return new MsgSwapExactAmountIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountIn {
    return new MsgSwapExactAmountIn().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountIn | PlainMessage<MsgSwapExactAmountIn> | undefined, b: MsgSwapExactAmountIn | PlainMessage<MsgSwapExactAmountIn> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountIn, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountInResponse
 */
export class MsgSwapExactAmountInResponse extends Message<MsgSwapExactAmountInResponse> {
  /**
   * @generated from field: string token_out_amount = 1;
   */
  tokenOutAmount = "";

  constructor(data?: PartialMessage<MsgSwapExactAmountInResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountInResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_out_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountInResponse {
    return new MsgSwapExactAmountInResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountInResponse {
    return new MsgSwapExactAmountInResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountInResponse {
    return new MsgSwapExactAmountInResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountInResponse | PlainMessage<MsgSwapExactAmountInResponse> | undefined, b: MsgSwapExactAmountInResponse | PlainMessage<MsgSwapExactAmountInResponse> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountInResponse, a, b);
  }
}

/**
 * ===================== MsgSplitRouteSwapExactAmountIn
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn
 */
export class MsgSplitRouteSwapExactAmountIn extends Message<MsgSplitRouteSwapExactAmountIn> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountInSplitRoute routes = 2;
   */
  routes: SwapAmountInSplitRoute[] = [];

  /**
   * @generated from field: string token_in_denom = 3;
   */
  tokenInDenom = "";

  /**
   * @generated from field: string token_out_min_amount = 4;
   */
  tokenOutMinAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountInSplitRoute, repeated: true },
    { no: 3, name: "token_in_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_out_min_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountIn {
    return new MsgSplitRouteSwapExactAmountIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountIn {
    return new MsgSplitRouteSwapExactAmountIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountIn {
    return new MsgSplitRouteSwapExactAmountIn().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountIn | PlainMessage<MsgSplitRouteSwapExactAmountIn> | undefined, b: MsgSplitRouteSwapExactAmountIn | PlainMessage<MsgSplitRouteSwapExactAmountIn> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountIn, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse
 */
export class MsgSplitRouteSwapExactAmountInResponse extends Message<MsgSplitRouteSwapExactAmountInResponse> {
  /**
   * @generated from field: string token_out_amount = 1;
   */
  tokenOutAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountInResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_out_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountInResponse {
    return new MsgSplitRouteSwapExactAmountInResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountInResponse {
    return new MsgSplitRouteSwapExactAmountInResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountInResponse {
    return new MsgSplitRouteSwapExactAmountInResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountInResponse | PlainMessage<MsgSplitRouteSwapExactAmountInResponse> | undefined, b: MsgSplitRouteSwapExactAmountInResponse | PlainMessage<MsgSplitRouteSwapExactAmountInResponse> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountInResponse, a, b);
  }
}

/**
 * ===================== MsgSwapExactAmountOut
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountOut
 */
export class MsgSwapExactAmountOut extends Message<MsgSwapExactAmountOut> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountOutRoute routes = 2;
   */
  routes: SwapAmountOutRoute[] = [];

  /**
   * @generated from field: string token_in_max_amount = 3;
   */
  tokenInMaxAmount = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin token_out = 4;
   */
  tokenOut?: Coin;

  constructor(data?: PartialMessage<MsgSwapExactAmountOut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountOut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountOutRoute, repeated: true },
    { no: 3, name: "token_in_max_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_out", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountOut {
    return new MsgSwapExactAmountOut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOut {
    return new MsgSwapExactAmountOut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOut {
    return new MsgSwapExactAmountOut().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountOut | PlainMessage<MsgSwapExactAmountOut> | undefined, b: MsgSwapExactAmountOut | PlainMessage<MsgSwapExactAmountOut> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountOut, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSwapExactAmountOutResponse
 */
export class MsgSwapExactAmountOutResponse extends Message<MsgSwapExactAmountOutResponse> {
  /**
   * @generated from field: string token_in_amount = 1;
   */
  tokenInAmount = "";

  constructor(data?: PartialMessage<MsgSwapExactAmountOutResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSwapExactAmountOutResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_in_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapExactAmountOutResponse {
    return new MsgSwapExactAmountOutResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOutResponse {
    return new MsgSwapExactAmountOutResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapExactAmountOutResponse {
    return new MsgSwapExactAmountOutResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapExactAmountOutResponse | PlainMessage<MsgSwapExactAmountOutResponse> | undefined, b: MsgSwapExactAmountOutResponse | PlainMessage<MsgSwapExactAmountOutResponse> | undefined): boolean {
    return proto3.util.equals(MsgSwapExactAmountOutResponse, a, b);
  }
}

/**
 * ===================== MsgSplitRouteSwapExactAmountOut
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut
 */
export class MsgSplitRouteSwapExactAmountOut extends Message<MsgSplitRouteSwapExactAmountOut> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.SwapAmountOutSplitRoute routes = 2;
   */
  routes: SwapAmountOutSplitRoute[] = [];

  /**
   * @generated from field: string token_out_denom = 3;
   */
  tokenOutDenom = "";

  /**
   * @generated from field: string token_in_max_amount = 4;
   */
  tokenInMaxAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountOut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "routes", kind: "message", T: SwapAmountOutSplitRoute, repeated: true },
    { no: 3, name: "token_out_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_in_max_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountOut {
    return new MsgSplitRouteSwapExactAmountOut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOut {
    return new MsgSplitRouteSwapExactAmountOut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOut {
    return new MsgSplitRouteSwapExactAmountOut().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountOut | PlainMessage<MsgSplitRouteSwapExactAmountOut> | undefined, b: MsgSplitRouteSwapExactAmountOut | PlainMessage<MsgSplitRouteSwapExactAmountOut> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountOut, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse
 */
export class MsgSplitRouteSwapExactAmountOutResponse extends Message<MsgSplitRouteSwapExactAmountOutResponse> {
  /**
   * @generated from field: string token_in_amount = 1;
   */
  tokenInAmount = "";

  constructor(data?: PartialMessage<MsgSplitRouteSwapExactAmountOutResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_in_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSplitRouteSwapExactAmountOutResponse {
    return new MsgSplitRouteSwapExactAmountOutResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOutResponse {
    return new MsgSplitRouteSwapExactAmountOutResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSplitRouteSwapExactAmountOutResponse {
    return new MsgSplitRouteSwapExactAmountOutResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSplitRouteSwapExactAmountOutResponse | PlainMessage<MsgSplitRouteSwapExactAmountOutResponse> | undefined, b: MsgSplitRouteSwapExactAmountOutResponse | PlainMessage<MsgSplitRouteSwapExactAmountOutResponse> | undefined): boolean {
    return proto3.util.equals(MsgSplitRouteSwapExactAmountOutResponse, a, b);
  }
}

/**
 * ===================== MsgSetDenomPairTakerFee
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFee
 */
export class MsgSetDenomPairTakerFee extends Message<MsgSetDenomPairTakerFee> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: repeated osmosis.poolmanager.v1beta1.DenomPairTakerFee denom_pair_taker_fee = 2;
   */
  denomPairTakerFee: DenomPairTakerFee[] = [];

  constructor(data?: PartialMessage<MsgSetDenomPairTakerFee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom_pair_taker_fee", kind: "message", T: DenomPairTakerFee, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomPairTakerFee {
    return new MsgSetDenomPairTakerFee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFee {
    return new MsgSetDenomPairTakerFee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFee {
    return new MsgSetDenomPairTakerFee().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomPairTakerFee | PlainMessage<MsgSetDenomPairTakerFee> | undefined, b: MsgSetDenomPairTakerFee | PlainMessage<MsgSetDenomPairTakerFee> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomPairTakerFee, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse
 */
export class MsgSetDenomPairTakerFeeResponse extends Message<MsgSetDenomPairTakerFeeResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  constructor(data?: PartialMessage<MsgSetDenomPairTakerFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomPairTakerFeeResponse {
    return new MsgSetDenomPairTakerFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFeeResponse {
    return new MsgSetDenomPairTakerFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomPairTakerFeeResponse {
    return new MsgSetDenomPairTakerFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomPairTakerFeeResponse | PlainMessage<MsgSetDenomPairTakerFeeResponse> | undefined, b: MsgSetDenomPairTakerFeeResponse | PlainMessage<MsgSetDenomPairTakerFeeResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomPairTakerFeeResponse, a, b);
  }
}

/**
 * ===================== MsgSetTakerFeeShareAgreementForDenom
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenom
 */
export class MsgSetTakerFeeShareAgreementForDenom extends Message<MsgSetTakerFeeShareAgreementForDenom> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * denom is the denom that the taker fee share agreement is being set for.
   * Ex. If this is set to "nBTC", then any trade route that includes "nBTC"
   * will have the skim_percent skimmed from the taker fees and sent to the
   * skim_address.
   *
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * skim_percent is the percentage of taker fees that will be skimmed for the
   * bridge provider, in the event that the bridge provider's denom is included
   * in the swap route.
   *
   * @generated from field: string skim_percent = 3;
   */
  skimPercent = "";

  /**
   * skim_address is the address belonging to the respective bridge provider
   * that the skimmed taker fees will be sent to at the end of each epoch.
   *
   * @generated from field: string skim_address = 4;
   */
  skimAddress = "";

  constructor(data?: PartialMessage<MsgSetTakerFeeShareAgreementForDenom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "skim_percent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "skim_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetTakerFeeShareAgreementForDenom {
    return new MsgSetTakerFeeShareAgreementForDenom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetTakerFeeShareAgreementForDenom {
    return new MsgSetTakerFeeShareAgreementForDenom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetTakerFeeShareAgreementForDenom {
    return new MsgSetTakerFeeShareAgreementForDenom().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetTakerFeeShareAgreementForDenom | PlainMessage<MsgSetTakerFeeShareAgreementForDenom> | undefined, b: MsgSetTakerFeeShareAgreementForDenom | PlainMessage<MsgSetTakerFeeShareAgreementForDenom> | undefined): boolean {
    return proto3.util.equals(MsgSetTakerFeeShareAgreementForDenom, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenomResponse
 */
export class MsgSetTakerFeeShareAgreementForDenomResponse extends Message<MsgSetTakerFeeShareAgreementForDenomResponse> {
  constructor(data?: PartialMessage<MsgSetTakerFeeShareAgreementForDenomResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenomResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetTakerFeeShareAgreementForDenomResponse {
    return new MsgSetTakerFeeShareAgreementForDenomResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetTakerFeeShareAgreementForDenomResponse {
    return new MsgSetTakerFeeShareAgreementForDenomResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetTakerFeeShareAgreementForDenomResponse {
    return new MsgSetTakerFeeShareAgreementForDenomResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetTakerFeeShareAgreementForDenomResponse | PlainMessage<MsgSetTakerFeeShareAgreementForDenomResponse> | undefined, b: MsgSetTakerFeeShareAgreementForDenomResponse | PlainMessage<MsgSetTakerFeeShareAgreementForDenomResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetTakerFeeShareAgreementForDenomResponse, a, b);
  }
}

/**
 * ===================== MsgSetRegisteredAlloyedPool
 *
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetRegisteredAlloyedPool
 */
export class MsgSetRegisteredAlloyedPool extends Message<MsgSetRegisteredAlloyedPool> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * pool_id is the id of the pool that is being registered as an alloyed pool.
   * Only alloyed pools that intend to be used in taker fee revenue sharing
   * should be registered.
   *
   * @generated from field: uint64 pool_id = 2;
   */
  poolId = protoInt64.zero;

  constructor(data?: PartialMessage<MsgSetRegisteredAlloyedPool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetRegisteredAlloyedPool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pool_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetRegisteredAlloyedPool {
    return new MsgSetRegisteredAlloyedPool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetRegisteredAlloyedPool {
    return new MsgSetRegisteredAlloyedPool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetRegisteredAlloyedPool {
    return new MsgSetRegisteredAlloyedPool().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetRegisteredAlloyedPool | PlainMessage<MsgSetRegisteredAlloyedPool> | undefined, b: MsgSetRegisteredAlloyedPool | PlainMessage<MsgSetRegisteredAlloyedPool> | undefined): boolean {
    return proto3.util.equals(MsgSetRegisteredAlloyedPool, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.MsgSetRegisteredAlloyedPoolResponse
 */
export class MsgSetRegisteredAlloyedPoolResponse extends Message<MsgSetRegisteredAlloyedPoolResponse> {
  constructor(data?: PartialMessage<MsgSetRegisteredAlloyedPoolResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.MsgSetRegisteredAlloyedPoolResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetRegisteredAlloyedPoolResponse {
    return new MsgSetRegisteredAlloyedPoolResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetRegisteredAlloyedPoolResponse {
    return new MsgSetRegisteredAlloyedPoolResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetRegisteredAlloyedPoolResponse {
    return new MsgSetRegisteredAlloyedPoolResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetRegisteredAlloyedPoolResponse | PlainMessage<MsgSetRegisteredAlloyedPoolResponse> | undefined, b: MsgSetRegisteredAlloyedPoolResponse | PlainMessage<MsgSetRegisteredAlloyedPoolResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetRegisteredAlloyedPoolResponse, a, b);
  }
}

/**
 * @generated from message osmosis.poolmanager.v1beta1.DenomPairTakerFee
 */
export class DenomPairTakerFee extends Message<DenomPairTakerFee> {
  /**
   * DEPRECATED: Now that we are using uni-directional trading pairs, we are
   * using tokenInDenom and tokenOutDenom instead of denom0 and denom1 to
   * prevent confusion.
   *
   * @generated from field: string denom0 = 1 [deprecated = true];
   * @deprecated
   */
  denom0 = "";

  /**
   * @generated from field: string denom1 = 2 [deprecated = true];
   * @deprecated
   */
  denom1 = "";

  /**
   * @generated from field: string taker_fee = 3;
   */
  takerFee = "";

  /**
   * @generated from field: string tokenInDenom = 4;
   */
  tokenInDenom = "";

  /**
   * @generated from field: string tokenOutDenom = 5;
   */
  tokenOutDenom = "";

  constructor(data?: PartialMessage<DenomPairTakerFee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.poolmanager.v1beta1.DenomPairTakerFee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom0", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "taker_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "tokenInDenom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "tokenOutDenom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomPairTakerFee {
    return new DenomPairTakerFee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomPairTakerFee {
    return new DenomPairTakerFee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomPairTakerFee {
    return new DenomPairTakerFee().fromJsonString(jsonString, options);
  }

  static equals(a: DenomPairTakerFee | PlainMessage<DenomPairTakerFee> | undefined, b: DenomPairTakerFee | PlainMessage<DenomPairTakerFee> | undefined): boolean {
    return proto3.util.equals(DenomPairTakerFee, a, b);
  }
}

