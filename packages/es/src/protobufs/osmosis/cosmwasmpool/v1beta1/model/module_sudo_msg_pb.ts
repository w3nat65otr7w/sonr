// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/cosmwasmpool/v1beta1/model/module_sudo_msg.proto (package osmosis.cosmwasmpool.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * ===================== SwapExactAmountIn
 *
 * @generated from message osmosis.cosmwasmpool.v1beta1.SwapExactAmountIn
 */
export class SwapExactAmountIn extends Message<SwapExactAmountIn> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * token_in is the token to be sent to the pool.
   *
   * @generated from field: cosmos.base.v1beta1.Coin token_in = 2;
   */
  tokenIn?: Coin;

  /**
   * token_out_denom is the token denom to be received from the pool.
   *
   * @generated from field: string token_out_denom = 3;
   */
  tokenOutDenom = "";

  /**
   * token_out_min_amount is the minimum amount of token_out to be received from
   * the pool.
   *
   * @generated from field: string token_out_min_amount = 4;
   */
  tokenOutMinAmount = "";

  /**
   * swap_fee is the swap fee for this swap estimate.
   *
   * @generated from field: string swap_fee = 5;
   */
  swapFee = "";

  constructor(data?: PartialMessage<SwapExactAmountIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.cosmwasmpool.v1beta1.SwapExactAmountIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "token_in", kind: "message", T: Coin },
    { no: 3, name: "token_out_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_out_min_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "swap_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapExactAmountIn {
    return new SwapExactAmountIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapExactAmountIn {
    return new SwapExactAmountIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapExactAmountIn {
    return new SwapExactAmountIn().fromJsonString(jsonString, options);
  }

  static equals(a: SwapExactAmountIn | PlainMessage<SwapExactAmountIn> | undefined, b: SwapExactAmountIn | PlainMessage<SwapExactAmountIn> | undefined): boolean {
    return proto3.util.equals(SwapExactAmountIn, a, b);
  }
}

/**
 * @generated from message osmosis.cosmwasmpool.v1beta1.SwapExactAmountInSudoMsg
 */
export class SwapExactAmountInSudoMsg extends Message<SwapExactAmountInSudoMsg> {
  /**
   * swap_exact_amount_in is the structure containing all the request
   * information for this message.
   *
   * @generated from field: osmosis.cosmwasmpool.v1beta1.SwapExactAmountIn swap_exact_amount_in = 1;
   */
  swapExactAmountIn?: SwapExactAmountIn;

  constructor(data?: PartialMessage<SwapExactAmountInSudoMsg>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.cosmwasmpool.v1beta1.SwapExactAmountInSudoMsg";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "swap_exact_amount_in", kind: "message", T: SwapExactAmountIn },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapExactAmountInSudoMsg {
    return new SwapExactAmountInSudoMsg().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapExactAmountInSudoMsg {
    return new SwapExactAmountInSudoMsg().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapExactAmountInSudoMsg {
    return new SwapExactAmountInSudoMsg().fromJsonString(jsonString, options);
  }

  static equals(a: SwapExactAmountInSudoMsg | PlainMessage<SwapExactAmountInSudoMsg> | undefined, b: SwapExactAmountInSudoMsg | PlainMessage<SwapExactAmountInSudoMsg> | undefined): boolean {
    return proto3.util.equals(SwapExactAmountInSudoMsg, a, b);
  }
}

/**
 * @generated from message osmosis.cosmwasmpool.v1beta1.SwapExactAmountInSudoMsgResponse
 */
export class SwapExactAmountInSudoMsgResponse extends Message<SwapExactAmountInSudoMsgResponse> {
  /**
   * token_out_amount is the token out computed from this swap estimate call.
   *
   * @generated from field: string token_out_amount = 1;
   */
  tokenOutAmount = "";

  constructor(data?: PartialMessage<SwapExactAmountInSudoMsgResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.cosmwasmpool.v1beta1.SwapExactAmountInSudoMsgResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_out_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapExactAmountInSudoMsgResponse {
    return new SwapExactAmountInSudoMsgResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapExactAmountInSudoMsgResponse {
    return new SwapExactAmountInSudoMsgResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapExactAmountInSudoMsgResponse {
    return new SwapExactAmountInSudoMsgResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SwapExactAmountInSudoMsgResponse | PlainMessage<SwapExactAmountInSudoMsgResponse> | undefined, b: SwapExactAmountInSudoMsgResponse | PlainMessage<SwapExactAmountInSudoMsgResponse> | undefined): boolean {
    return proto3.util.equals(SwapExactAmountInSudoMsgResponse, a, b);
  }
}

/**
 * ===================== SwapExactAmountOut
 *
 * @generated from message osmosis.cosmwasmpool.v1beta1.SwapExactAmountOut
 */
export class SwapExactAmountOut extends Message<SwapExactAmountOut> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * token_out is the token to be sent out of the pool.
   *
   * @generated from field: cosmos.base.v1beta1.Coin token_out = 2;
   */
  tokenOut?: Coin;

  /**
   * token_in_denom is the token denom to be sent too the pool.
   *
   * @generated from field: string token_in_denom = 3;
   */
  tokenInDenom = "";

  /**
   * token_in_max_amount is the maximum amount of token_in to be sent to the
   * pool.
   *
   * @generated from field: string token_in_max_amount = 4;
   */
  tokenInMaxAmount = "";

  /**
   * swap_fee is the swap fee for this swap estimate.
   *
   * @generated from field: string swap_fee = 5;
   */
  swapFee = "";

  constructor(data?: PartialMessage<SwapExactAmountOut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.cosmwasmpool.v1beta1.SwapExactAmountOut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "token_out", kind: "message", T: Coin },
    { no: 3, name: "token_in_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "token_in_max_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "swap_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapExactAmountOut {
    return new SwapExactAmountOut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapExactAmountOut {
    return new SwapExactAmountOut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapExactAmountOut {
    return new SwapExactAmountOut().fromJsonString(jsonString, options);
  }

  static equals(a: SwapExactAmountOut | PlainMessage<SwapExactAmountOut> | undefined, b: SwapExactAmountOut | PlainMessage<SwapExactAmountOut> | undefined): boolean {
    return proto3.util.equals(SwapExactAmountOut, a, b);
  }
}

/**
 * @generated from message osmosis.cosmwasmpool.v1beta1.SwapExactAmountOutSudoMsg
 */
export class SwapExactAmountOutSudoMsg extends Message<SwapExactAmountOutSudoMsg> {
  /**
   * swap_exact_amount_out is the structure containing all the request
   * information for this message.
   *
   * @generated from field: osmosis.cosmwasmpool.v1beta1.SwapExactAmountOut swap_exact_amount_out = 1;
   */
  swapExactAmountOut?: SwapExactAmountOut;

  constructor(data?: PartialMessage<SwapExactAmountOutSudoMsg>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.cosmwasmpool.v1beta1.SwapExactAmountOutSudoMsg";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "swap_exact_amount_out", kind: "message", T: SwapExactAmountOut },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapExactAmountOutSudoMsg {
    return new SwapExactAmountOutSudoMsg().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapExactAmountOutSudoMsg {
    return new SwapExactAmountOutSudoMsg().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapExactAmountOutSudoMsg {
    return new SwapExactAmountOutSudoMsg().fromJsonString(jsonString, options);
  }

  static equals(a: SwapExactAmountOutSudoMsg | PlainMessage<SwapExactAmountOutSudoMsg> | undefined, b: SwapExactAmountOutSudoMsg | PlainMessage<SwapExactAmountOutSudoMsg> | undefined): boolean {
    return proto3.util.equals(SwapExactAmountOutSudoMsg, a, b);
  }
}

/**
 * @generated from message osmosis.cosmwasmpool.v1beta1.SwapExactAmountOutSudoMsgResponse
 */
export class SwapExactAmountOutSudoMsgResponse extends Message<SwapExactAmountOutSudoMsgResponse> {
  /**
   * token_in_amount is the token in computed from this swap estimate call.
   *
   * @generated from field: string token_in_amount = 1;
   */
  tokenInAmount = "";

  constructor(data?: PartialMessage<SwapExactAmountOutSudoMsgResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.cosmwasmpool.v1beta1.SwapExactAmountOutSudoMsgResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_in_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwapExactAmountOutSudoMsgResponse {
    return new SwapExactAmountOutSudoMsgResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwapExactAmountOutSudoMsgResponse {
    return new SwapExactAmountOutSudoMsgResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwapExactAmountOutSudoMsgResponse {
    return new SwapExactAmountOutSudoMsgResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SwapExactAmountOutSudoMsgResponse | PlainMessage<SwapExactAmountOutSudoMsgResponse> | undefined, b: SwapExactAmountOutSudoMsgResponse | PlainMessage<SwapExactAmountOutSudoMsgResponse> | undefined): boolean {
    return proto3.util.equals(SwapExactAmountOutSudoMsgResponse, a, b);
  }
}

