// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file osmosis/incentives/group.proto (package osmosis.incentives, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Gauge } from "./gauge_pb.js";

/**
 * SplittingPolicy determines the way we want to split incentives in groupGauges
 *
 * @generated from enum osmosis.incentives.SplittingPolicy
 */
export enum SplittingPolicy {
  /**
   * @generated from enum value: ByVolume = 0;
   */
  ByVolume = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(SplittingPolicy)
proto3.util.setEnumType(SplittingPolicy, "osmosis.incentives.SplittingPolicy", [
  { no: 0, name: "ByVolume" },
]);

/**
 * Note that while both InternalGaugeInfo and InternalGaugeRecord could
 * technically be replaced by DistrInfo and DistrRecord from the pool-incentives
 * module, we create separate types here to keep our abstractions clean and
 * readable (pool-incentives distribution abstractions are used in a very
 * specific way that does not directly relate to gauge logic). This also helps
 * us sidestep a refactor to avoid an import cycle.
 *
 * @generated from message osmosis.incentives.InternalGaugeInfo
 */
export class InternalGaugeInfo extends Message<InternalGaugeInfo> {
  /**
   * @generated from field: string total_weight = 1;
   */
  totalWeight = "";

  /**
   * @generated from field: repeated osmosis.incentives.InternalGaugeRecord gauge_records = 2;
   */
  gaugeRecords: InternalGaugeRecord[] = [];

  constructor(data?: PartialMessage<InternalGaugeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.InternalGaugeInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "gauge_records", kind: "message", T: InternalGaugeRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InternalGaugeInfo {
    return new InternalGaugeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InternalGaugeInfo {
    return new InternalGaugeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InternalGaugeInfo {
    return new InternalGaugeInfo().fromJsonString(jsonString, options);
  }

  static equals(a: InternalGaugeInfo | PlainMessage<InternalGaugeInfo> | undefined, b: InternalGaugeInfo | PlainMessage<InternalGaugeInfo> | undefined): boolean {
    return proto3.util.equals(InternalGaugeInfo, a, b);
  }
}

/**
 * @generated from message osmosis.incentives.InternalGaugeRecord
 */
export class InternalGaugeRecord extends Message<InternalGaugeRecord> {
  /**
   * @generated from field: uint64 gauge_id = 1;
   */
  gaugeId = protoInt64.zero;

  /**
   * CurrentWeight is the current weight of this gauge being distributed to for
   * this epoch. For instance, for volume splitting policy, this stores the
   * volume generated in the last epoch of the linked pool.
   *
   * @generated from field: string current_weight = 2;
   */
  currentWeight = "";

  /**
   * CumulativeWeight serves as a snapshot of the accumulator being tracked
   * based on splitting policy. For instance, for volume splitting policy, this
   * stores the cumulative volume for the linked pool at time of last update.
   *
   * @generated from field: string cumulative_weight = 3;
   */
  cumulativeWeight = "";

  constructor(data?: PartialMessage<InternalGaugeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.InternalGaugeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gauge_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "current_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cumulative_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InternalGaugeRecord {
    return new InternalGaugeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InternalGaugeRecord {
    return new InternalGaugeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InternalGaugeRecord {
    return new InternalGaugeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: InternalGaugeRecord | PlainMessage<InternalGaugeRecord> | undefined, b: InternalGaugeRecord | PlainMessage<InternalGaugeRecord> | undefined): boolean {
    return proto3.util.equals(InternalGaugeRecord, a, b);
  }
}

/**
 * Group is an object that stores a 1:1 mapped gauge ID, a list of pool gauge
 * info, and a splitting policy. These are grouped into a single abstraction to
 * allow for distribution of group incentives to internal gauges according to
 * the specified splitting policy.
 *
 * @generated from message osmosis.incentives.Group
 */
export class Group extends Message<Group> {
  /**
   * @generated from field: uint64 group_gauge_id = 1;
   */
  groupGaugeId = protoInt64.zero;

  /**
   * @generated from field: osmosis.incentives.InternalGaugeInfo internal_gauge_info = 2;
   */
  internalGaugeInfo?: InternalGaugeInfo;

  /**
   * @generated from field: osmosis.incentives.SplittingPolicy splitting_policy = 3;
   */
  splittingPolicy = SplittingPolicy.ByVolume;

  constructor(data?: PartialMessage<Group>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.Group";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_gauge_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "internal_gauge_info", kind: "message", T: InternalGaugeInfo },
    { no: 3, name: "splitting_policy", kind: "enum", T: proto3.getEnumType(SplittingPolicy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Group {
    return new Group().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJsonString(jsonString, options);
  }

  static equals(a: Group | PlainMessage<Group> | undefined, b: Group | PlainMessage<Group> | undefined): boolean {
    return proto3.util.equals(Group, a, b);
  }
}

/**
 * CreateGroup is called via governance to create a new group.
 * It takes an array of pool IDs to split the incentives across.
 *
 * @generated from message osmosis.incentives.CreateGroup
 */
export class CreateGroup extends Message<CreateGroup> {
  /**
   * @generated from field: repeated uint64 pool_ids = 1;
   */
  poolIds: bigint[] = [];

  constructor(data?: PartialMessage<CreateGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.CreateGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_ids", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateGroup {
    return new CreateGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateGroup {
    return new CreateGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateGroup {
    return new CreateGroup().fromJsonString(jsonString, options);
  }

  static equals(a: CreateGroup | PlainMessage<CreateGroup> | undefined, b: CreateGroup | PlainMessage<CreateGroup> | undefined): boolean {
    return proto3.util.equals(CreateGroup, a, b);
  }
}

/**
 * GroupsWithGauge is a helper struct that stores a group and its
 * associated gauge.
 *
 * @generated from message osmosis.incentives.GroupsWithGauge
 */
export class GroupsWithGauge extends Message<GroupsWithGauge> {
  /**
   * @generated from field: osmosis.incentives.Group group = 1;
   */
  group?: Group;

  /**
   * @generated from field: osmosis.incentives.Gauge gauge = 2;
   */
  gauge?: Gauge;

  constructor(data?: PartialMessage<GroupsWithGauge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "osmosis.incentives.GroupsWithGauge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group", kind: "message", T: Group },
    { no: 2, name: "gauge", kind: "message", T: Gauge },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupsWithGauge {
    return new GroupsWithGauge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupsWithGauge {
    return new GroupsWithGauge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupsWithGauge {
    return new GroupsWithGauge().fromJsonString(jsonString, options);
  }

  static equals(a: GroupsWithGauge | PlainMessage<GroupsWithGauge> | undefined, b: GroupsWithGauge | PlainMessage<GroupsWithGauge> | undefined): boolean {
    return proto3.util.equals(GroupsWithGauge, a, b);
  }
}

