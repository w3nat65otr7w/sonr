// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file dwn/v1/state.proto (package dwn.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * EncryptionMetadata contains metadata for consensus-based encryption
 *
 * @generated from message dwn.v1.EncryptionMetadata
 */
export class EncryptionMetadata extends Message<EncryptionMetadata> {
  /**
   * Encryption algorithm used (e.g., "AES-256-GCM")
   *
   * @generated from field: string algorithm = 1;
   */
  algorithm = "";

  /**
   * Input used for VRF consensus key derivation
   *
   * @generated from field: bytes consensus_input = 2;
   */
  consensusInput = new Uint8Array(0);

  /**
   * Nonce used for encryption
   *
   * @generated from field: bytes nonce = 3;
   */
  nonce = new Uint8Array(0);

  /**
   * Authentication tag from AES-GCM
   *
   * @generated from field: bytes auth_tag = 4;
   */
  authTag = new Uint8Array(0);

  /**
   * Block height when encryption was performed
   *
   * @generated from field: int64 encryption_height = 5;
   */
  encryptionHeight = protoInt64.zero;

  /**
   * Validator set participating in consensus
   *
   * @generated from field: repeated string validator_set = 6;
   */
  validatorSet: string[] = [];

  /**
   * Key rotation version
   *
   * @generated from field: uint64 key_version = 7;
   */
  keyVersion = protoInt64.zero;

  /**
   * Single node development mode flag
   *
   * @generated from field: bool single_node_mode = 8;
   */
  singleNodeMode = false;

  /**
   * HMAC-SHA256 authentication tag for data integrity
   *
   * @generated from field: bytes data_hmac = 9;
   */
  dataHmac = new Uint8Array(0);

  /**
   * Salt used for key derivation
   *
   * @generated from field: bytes key_derivation_salt = 10;
   */
  keyDerivationSalt = new Uint8Array(0);

  /**
   * Additional authenticated data (AAD) for AES-GCM
   *
   * @generated from field: bytes additional_data = 11;
   */
  additionalData = new Uint8Array(0);

  constructor(data?: PartialMessage<EncryptionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.EncryptionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "consensus_input", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "auth_tag", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "encryption_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "validator_set", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "key_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "single_node_mode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "data_hmac", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "key_derivation_salt", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "additional_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionMetadata {
    return new EncryptionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionMetadata {
    return new EncryptionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionMetadata {
    return new EncryptionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionMetadata | PlainMessage<EncryptionMetadata> | undefined, b: EncryptionMetadata | PlainMessage<EncryptionMetadata> | undefined): boolean {
    return proto3.util.equals(EncryptionMetadata, a, b);
  }
}

/**
 * EncryptionKeyState contains the current key and contributions for a given key version
 *
 * @generated from message dwn.v1.EncryptionKeyState
 */
export class EncryptionKeyState extends Message<EncryptionKeyState> {
  /**
   * Current encryption key (stored encrypted or as reference)
   *
   * @generated from field: bytes current_key = 1;
   */
  currentKey = new Uint8Array(0);

  /**
   * Key version/epoch identifier
   *
   * @generated from field: uint64 key_version = 2;
   */
  keyVersion = protoInt64.zero;

  /**
   * Validator set participating in consensus
   *
   * @generated from field: repeated string validator_set = 3;
   */
  validatorSet: string[] = [];

  /**
   * VRF contributions for this key generation round
   *
   * @generated from field: repeated dwn.v1.VRFContribution contributions = 4;
   */
  contributions: VRFContribution[] = [];

  /**
   * Last rotation timestamp (Unix timestamp)
   *
   * @generated from field: int64 last_rotation = 5;
   */
  lastRotation = protoInt64.zero;

  /**
   * Next scheduled rotation timestamp (Unix timestamp)
   *
   * @generated from field: int64 next_rotation = 6;
   */
  nextRotation = protoInt64.zero;

  /**
   * Single node development mode flag
   *
   * @generated from field: bool single_node_mode = 7;
   */
  singleNodeMode = false;

  /**
   * Usage count for this key (for usage-based rotation)
   *
   * @generated from field: uint64 usage_count = 8;
   */
  usageCount = protoInt64.zero;

  /**
   * Maximum usage count before rotation
   *
   * @generated from field: uint64 max_usage_count = 9;
   */
  maxUsageCount = protoInt64.zero;

  /**
   * Rotation interval in seconds (for time-based rotation)
   *
   * @generated from field: int64 rotation_interval = 10;
   */
  rotationInterval = protoInt64.zero;

  /**
   * Key creation timestamp (Unix timestamp)
   *
   * @generated from field: int64 created_at = 11;
   */
  createdAt = protoInt64.zero;

  /**
   * Previous key version for migration support
   *
   * @generated from field: uint64 previous_key_version = 12;
   */
  previousKeyVersion = protoInt64.zero;

  constructor(data?: PartialMessage<EncryptionKeyState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.EncryptionKeyState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "key_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "validator_set", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "contributions", kind: "message", T: VRFContribution, repeated: true },
    { no: 5, name: "last_rotation", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "next_rotation", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "single_node_mode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "usage_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "max_usage_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "rotation_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "created_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "previous_key_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionKeyState {
    return new EncryptionKeyState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionKeyState {
    return new EncryptionKeyState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionKeyState {
    return new EncryptionKeyState().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionKeyState | PlainMessage<EncryptionKeyState> | undefined, b: EncryptionKeyState | PlainMessage<EncryptionKeyState> | undefined): boolean {
    return proto3.util.equals(EncryptionKeyState, a, b);
  }
}

/**
 * VRFConsensusRound tracks a specific consensus round for key generation
 *
 * @generated from message dwn.v1.VRFConsensusRound
 */
export class VRFConsensusRound extends Message<VRFConsensusRound> {
  /**
   * Round number for this consensus round
   *
   * @generated from field: uint64 round_number = 1;
   */
  roundNumber = protoInt64.zero;

  /**
   * Key version this round is generating
   *
   * @generated from field: uint64 key_version = 2;
   */
  keyVersion = protoInt64.zero;

  /**
   * Number of contributions required for consensus
   *
   * @generated from field: uint32 required_contributions = 3;
   */
  requiredContributions = 0;

  /**
   * Number of contributions received so far
   *
   * @generated from field: uint32 received_contributions = 4;
   */
  receivedContributions = 0;

  /**
   * Current status: "waiting_for_contributions", "complete", "expired", "single_node_mode"
   *
   * @generated from field: string status = 5;
   */
  status = "";

  /**
   * Block height when this round expires
   *
   * @generated from field: int64 expiry_height = 6;
   */
  expiryHeight = protoInt64.zero;

  /**
   * Block height when round was initiated
   *
   * @generated from field: int64 initiated_height = 7;
   */
  initiatedHeight = protoInt64.zero;

  /**
   * Consensus input used for this round
   *
   * @generated from field: bytes consensus_input = 8;
   */
  consensusInput = new Uint8Array(0);

  /**
   * Whether this round completed successfully
   *
   * @generated from field: bool completed = 9;
   */
  completed = false;

  constructor(data?: PartialMessage<VRFConsensusRound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.VRFConsensusRound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "round_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "key_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "required_contributions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "received_contributions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "expiry_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "initiated_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "consensus_input", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "completed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VRFConsensusRound {
    return new VRFConsensusRound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VRFConsensusRound {
    return new VRFConsensusRound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VRFConsensusRound {
    return new VRFConsensusRound().fromJsonString(jsonString, options);
  }

  static equals(a: VRFConsensusRound | PlainMessage<VRFConsensusRound> | undefined, b: VRFConsensusRound | PlainMessage<VRFConsensusRound> | undefined): boolean {
    return proto3.util.equals(VRFConsensusRound, a, b);
  }
}

/**
 * EncryptionStats contains encryption statistics for monitoring
 *
 * @generated from message dwn.v1.EncryptionStats
 */
export class EncryptionStats extends Message<EncryptionStats> {
  /**
   * Total number of encrypted records
   *
   * @generated from field: int64 total_encrypted_records = 1;
   */
  totalEncryptedRecords = protoInt64.zero;

  /**
   * Total number of decryption errors
   *
   * @generated from field: int64 total_decryption_errors = 2;
   */
  totalDecryptionErrors = protoInt64.zero;

  /**
   * Last encryption height
   *
   * @generated from field: int64 last_encryption_height = 3;
   */
  lastEncryptionHeight = protoInt64.zero;

  constructor(data?: PartialMessage<EncryptionStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.EncryptionStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_encrypted_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "total_decryption_errors", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "last_encryption_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptionStats {
    return new EncryptionStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptionStats {
    return new EncryptionStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptionStats {
    return new EncryptionStats().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptionStats | PlainMessage<EncryptionStats> | undefined, b: EncryptionStats | PlainMessage<EncryptionStats> | undefined): boolean {
    return proto3.util.equals(EncryptionStats, a, b);
  }
}

/**
 * SaltStore contains salt management for encryption operations
 *
 * @generated from message dwn.v1.SaltStore
 */
export class SaltStore extends Message<SaltStore> {
  /**
   * Unique identifier for the encrypted record
   *
   * @generated from field: string record_id = 1;
   */
  recordId = "";

  /**
   * Salt value used for key derivation
   *
   * @generated from field: bytes salt_value = 2;
   */
  saltValue = new Uint8Array(0);

  /**
   * Creation timestamp (Unix timestamp)
   *
   * @generated from field: int64 created_at = 3;
   */
  createdAt = protoInt64.zero;

  /**
   * Key version associated with this salt
   *
   * @generated from field: uint64 key_version = 4;
   */
  keyVersion = protoInt64.zero;

  /**
   * Algorithm used with this salt (e.g., "PBKDF2-SHA256")
   *
   * @generated from field: string algorithm = 5;
   */
  algorithm = "";

  constructor(data?: PartialMessage<SaltStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.SaltStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "record_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "salt_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "created_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "key_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SaltStore {
    return new SaltStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SaltStore {
    return new SaltStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SaltStore {
    return new SaltStore().fromJsonString(jsonString, options);
  }

  static equals(a: SaltStore | PlainMessage<SaltStore> | undefined, b: SaltStore | PlainMessage<SaltStore> | undefined): boolean {
    return proto3.util.equals(SaltStore, a, b);
  }
}

/**
 * VRFContribution contains a VRF contribution for a given validator
 *
 * @generated from message dwn.v1.VRFContribution
 */
export class VRFContribution extends Message<VRFContribution> {
  /**
   * Validator address
   *
   * @generated from field: string validator_address = 1;
   */
  validatorAddress = "";

  /**
   * VRF randomness output
   *
   * @generated from field: bytes randomness = 2;
   */
  randomness = new Uint8Array(0);

  /**
   * VRF proof for verification
   *
   * @generated from field: bytes proof = 3;
   */
  proof = new Uint8Array(0);

  /**
   * Block height when contribution was made
   *
   * @generated from field: int64 block_height = 4;
   */
  blockHeight = protoInt64.zero;

  /**
   * Unix timestamp when contribution was submitted
   *
   * @generated from field: int64 timestamp = 5;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<VRFContribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.VRFContribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "randomness", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "proof", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "block_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VRFContribution {
    return new VRFContribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VRFContribution {
    return new VRFContribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VRFContribution {
    return new VRFContribution().fromJsonString(jsonString, options);
  }

  static equals(a: VRFContribution | PlainMessage<VRFContribution> | undefined, b: VRFContribution | PlainMessage<VRFContribution> | undefined): boolean {
    return proto3.util.equals(VRFContribution, a, b);
  }
}

/**
 * EncryptedDWNRecord contains an encrypted DWN record
 *
 * @generated from message dwn.v1.EncryptedDWNRecord
 */
export class EncryptedDWNRecord extends Message<EncryptedDWNRecord> {
  /**
   * Unique identifier for the record
   *
   * @generated from field: string record_id = 1;
   */
  recordId = "";

  /**
   * Encrypted data
   *
   * @generated from field: bytes encrypted_data = 2;
   */
  encryptedData = new Uint8Array(0);

  /**
   * Nonce used for encryption
   *
   * @generated from field: bytes nonce = 3;
   */
  nonce = new Uint8Array(0);

  /**
   * Key version
   *
   * @generated from field: uint64 key_version = 4;
   */
  keyVersion = protoInt64.zero;

  /**
   * IPFS hash of the record data
   *
   * @generated from field: string ipfs_hash = 5;
   */
  ipfsHash = "";

  constructor(data?: PartialMessage<EncryptedDWNRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.EncryptedDWNRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "record_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "encrypted_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "key_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "ipfs_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptedDWNRecord {
    return new EncryptedDWNRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptedDWNRecord {
    return new EncryptedDWNRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptedDWNRecord {
    return new EncryptedDWNRecord().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptedDWNRecord | PlainMessage<EncryptedDWNRecord> | undefined, b: EncryptedDWNRecord | PlainMessage<EncryptedDWNRecord> | undefined): boolean {
    return proto3.util.equals(EncryptedDWNRecord, a, b);
  }
}

/**
 * EnclaveData represents encrypted private key material within a secure enclave
 *
 * @generated from message dwn.v1.EnclaveData
 */
export class EnclaveData extends Message<EnclaveData> {
  /**
   * Encrypted private key material from the WASM enclave
   *
   * @generated from field: bytes private_data = 1;
   */
  privateData = new Uint8Array(0);

  /**
   * Public key corresponding to the private key
   *
   * @generated from field: bytes public_key = 2;
   */
  publicKey = new Uint8Array(0);

  /**
   * Unique identifier for the enclave instance
   *
   * @generated from field: string enclave_id = 3;
   */
  enclaveId = "";

  /**
   * Version number for refresh tracking
   *
   * @generated from field: int64 version = 4;
   */
  version = protoInt64.zero;

  constructor(data?: PartialMessage<EnclaveData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.EnclaveData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "private_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "enclave_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnclaveData {
    return new EnclaveData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnclaveData {
    return new EnclaveData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnclaveData {
    return new EnclaveData().fromJsonString(jsonString, options);
  }

  static equals(a: EnclaveData | PlainMessage<EnclaveData> | undefined, b: EnclaveData | PlainMessage<EnclaveData> | undefined): boolean {
    return proto3.util.equals(EnclaveData, a, b);
  }
}

/**
 * DWNMessageDescriptor contains metadata about a DWN message
 *
 * @generated from message dwn.v1.DWNMessageDescriptor
 */
export class DWNMessageDescriptor extends Message<DWNMessageDescriptor> {
  /**
   * Interface type (e.g., "Records", "Protocols", "Permissions")
   *
   * @generated from field: string interface_name = 1;
   */
  interfaceName = "";

  /**
   * Method name (e.g., "Write", "Query", "Configure")
   *
   * @generated from field: string method = 2;
   */
  method = "";

  /**
   * ISO 8601 timestamp of when the message was created
   *
   * @generated from field: string message_timestamp = 3;
   */
  messageTimestamp = "";

  /**
   * CID of the message data
   *
   * @generated from field: string data_cid = 4;
   */
  dataCid = "";

  /**
   * Size of the data in bytes
   *
   * @generated from field: int64 data_size = 5;
   */
  dataSize = protoInt64.zero;

  /**
   * MIME type of the data
   *
   * @generated from field: string data_format = 6;
   */
  dataFormat = "";

  constructor(data?: PartialMessage<DWNMessageDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.DWNMessageDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interface_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "message_timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "data_cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "data_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "data_format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DWNMessageDescriptor {
    return new DWNMessageDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DWNMessageDescriptor {
    return new DWNMessageDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DWNMessageDescriptor {
    return new DWNMessageDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: DWNMessageDescriptor | PlainMessage<DWNMessageDescriptor> | undefined, b: DWNMessageDescriptor | PlainMessage<DWNMessageDescriptor> | undefined): boolean {
    return proto3.util.equals(DWNMessageDescriptor, a, b);
  }
}

/**
 * DWNRecord represents a record stored in a Decentralized Web Node
 *
 * @generated from message dwn.v1.DWNRecord
 */
export class DWNRecord extends Message<DWNRecord> {
  /**
   * Unique identifier for the record
   *
   * @generated from field: string record_id = 1;
   */
  recordId = "";

  /**
   * DID of the DWN target
   *
   * @generated from field: string target = 2;
   */
  target = "";

  /**
   * Message descriptor
   *
   * @generated from field: dwn.v1.DWNMessageDescriptor descriptor = 3;
   */
  descriptor?: DWNMessageDescriptor;

  /**
   * Authorization JWT or signature
   *
   * @generated from field: string authorization = 4;
   */
  authorization = "";

  /**
   * Record data payload
   *
   * @generated from field: bytes data = 5;
   */
  data = new Uint8Array(0);

  /**
   * Optional protocol URI this record conforms to
   *
   * @generated from field: string protocol = 6;
   */
  protocol = "";

  /**
   * Optional protocol path
   *
   * @generated from field: string protocol_path = 7;
   */
  protocolPath = "";

  /**
   * Optional schema URI for data validation
   *
   * @generated from field: string schema = 8;
   */
  schema = "";

  /**
   * Optional parent record ID for threading
   *
   * @generated from field: string parent_id = 9;
   */
  parentId = "";

  /**
   * Published flag for public visibility
   *
   * @generated from field: bool published = 10;
   */
  published = false;

  /**
   * Attestation signature
   *
   * @generated from field: string attestation = 11;
   */
  attestation = "";

  /**
   * Encryption details (legacy field)
   *
   * @generated from field: string encryption = 12;
   */
  encryption = "";

  /**
   * Key derivation scheme (legacy field)
   *
   * @generated from field: string key_derivation_scheme = 13;
   */
  keyDerivationScheme = "";

  /**
   * Creation timestamp (Unix timestamp)
   *
   * @generated from field: int64 created_at = 14;
   */
  createdAt = protoInt64.zero;

  /**
   * Last update timestamp (Unix timestamp)
   *
   * @generated from field: int64 updated_at = 15;
   */
  updatedAt = protoInt64.zero;

  /**
   * Block height when created
   *
   * @generated from field: int64 created_height = 16;
   */
  createdHeight = protoInt64.zero;

  /**
   * Encryption metadata for consensus-based encryption
   *
   * @generated from field: dwn.v1.EncryptionMetadata encryption_metadata = 17;
   */
  encryptionMetadata?: EncryptionMetadata;

  /**
   * Flag indicating if the record is encrypted
   *
   * @generated from field: bool is_encrypted = 18;
   */
  isEncrypted = false;

  constructor(data?: PartialMessage<DWNRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.DWNRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "record_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "descriptor", kind: "message", T: DWNMessageDescriptor },
    { no: 4, name: "authorization", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "protocol_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "parent_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "published", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "attestation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "encryption", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "key_derivation_scheme", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "created_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 15, name: "updated_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 16, name: "created_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 17, name: "encryption_metadata", kind: "message", T: EncryptionMetadata },
    { no: 18, name: "is_encrypted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DWNRecord {
    return new DWNRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DWNRecord {
    return new DWNRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DWNRecord {
    return new DWNRecord().fromJsonString(jsonString, options);
  }

  static equals(a: DWNRecord | PlainMessage<DWNRecord> | undefined, b: DWNRecord | PlainMessage<DWNRecord> | undefined): boolean {
    return proto3.util.equals(DWNRecord, a, b);
  }
}

/**
 * DWNProtocol represents a configured protocol in a DWN
 *
 * @generated from message dwn.v1.DWNProtocol
 */
export class DWNProtocol extends Message<DWNProtocol> {
  /**
   * DID of the DWN target
   *
   * @generated from field: string target = 1;
   */
  target = "";

  /**
   * Protocol URI identifier
   *
   * @generated from field: string protocol_uri = 2;
   */
  protocolUri = "";

  /**
   * Protocol definition JSON
   *
   * @generated from field: bytes definition = 3;
   */
  definition = new Uint8Array(0);

  /**
   * Published flag for discoverability
   *
   * @generated from field: bool published = 4;
   */
  published = false;

  /**
   * Creation timestamp (Unix timestamp)
   *
   * @generated from field: int64 created_at = 5;
   */
  createdAt = protoInt64.zero;

  /**
   * Block height when created
   *
   * @generated from field: int64 created_height = 6;
   */
  createdHeight = protoInt64.zero;

  constructor(data?: PartialMessage<DWNProtocol>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.DWNProtocol";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "protocol_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "definition", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "published", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "created_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "created_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DWNProtocol {
    return new DWNProtocol().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DWNProtocol {
    return new DWNProtocol().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DWNProtocol {
    return new DWNProtocol().fromJsonString(jsonString, options);
  }

  static equals(a: DWNProtocol | PlainMessage<DWNProtocol> | undefined, b: DWNProtocol | PlainMessage<DWNProtocol> | undefined): boolean {
    return proto3.util.equals(DWNProtocol, a, b);
  }
}

/**
 * DWNPermission represents a permission grant in a DWN
 *
 * @generated from message dwn.v1.DWNPermission
 */
export class DWNPermission extends Message<DWNPermission> {
  /**
   * Unique identifier for the permission
   *
   * @generated from field: string permission_id = 1;
   */
  permissionId = "";

  /**
   * DID of the permission grantor
   *
   * @generated from field: string grantor = 2;
   */
  grantor = "";

  /**
   * DID of the permission grantee
   *
   * @generated from field: string grantee = 3;
   */
  grantee = "";

  /**
   * DID of the DWN target
   *
   * @generated from field: string target = 4;
   */
  target = "";

  /**
   * Interface scope (e.g., "Records", "Protocols")
   *
   * @generated from field: string interface_name = 5;
   */
  interfaceName = "";

  /**
   * Method scope (e.g., "Write", "Query")
   *
   * @generated from field: string method = 6;
   */
  method = "";

  /**
   * Optional protocol scope
   *
   * @generated from field: string protocol = 7;
   */
  protocol = "";

  /**
   * Optional record scope
   *
   * @generated from field: string record_id = 8;
   */
  recordId = "";

  /**
   * Permission conditions JSON
   *
   * @generated from field: bytes conditions = 9;
   */
  conditions = new Uint8Array(0);

  /**
   * Expiration timestamp (Unix timestamp)
   *
   * @generated from field: int64 expires_at = 10;
   */
  expiresAt = protoInt64.zero;

  /**
   * Creation timestamp (Unix timestamp)
   *
   * @generated from field: int64 created_at = 11;
   */
  createdAt = protoInt64.zero;

  /**
   * Revoked flag
   *
   * @generated from field: bool revoked = 12;
   */
  revoked = false;

  /**
   * Block height when created
   *
   * @generated from field: int64 created_height = 13;
   */
  createdHeight = protoInt64.zero;

  constructor(data?: PartialMessage<DWNPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.DWNPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permission_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "grantor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "interface_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "record_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "conditions", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "expires_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "created_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "revoked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "created_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DWNPermission {
    return new DWNPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DWNPermission {
    return new DWNPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DWNPermission {
    return new DWNPermission().fromJsonString(jsonString, options);
  }

  static equals(a: DWNPermission | PlainMessage<DWNPermission> | undefined, b: DWNPermission | PlainMessage<DWNPermission> | undefined): boolean {
    return proto3.util.equals(DWNPermission, a, b);
  }
}

/**
 * VaultState represents a vault instance for enclave-based operations
 *
 * @generated from message dwn.v1.VaultState
 */
export class VaultState extends Message<VaultState> {
  /**
   * Unique identifier for the vault
   *
   * @generated from field: string vault_id = 1;
   */
  vaultId = "";

  /**
   * Owner DID or address
   *
   * @generated from field: string owner = 2;
   */
  owner = "";

  /**
   * Enclave data containing encrypted keys
   *
   * @generated from field: dwn.v1.EnclaveData enclave_data = 3;
   */
  enclaveData?: EnclaveData;

  /**
   * Public key for verification
   *
   * @generated from field: bytes public_key = 4;
   */
  publicKey = new Uint8Array(0);

  /**
   * Creation timestamp (Unix timestamp)
   *
   * @generated from field: int64 created_at = 5;
   */
  createdAt = protoInt64.zero;

  /**
   * Last refresh timestamp (Unix timestamp)
   *
   * @generated from field: int64 last_refreshed = 6;
   */
  lastRefreshed = protoInt64.zero;

  /**
   * Block height when created
   *
   * @generated from field: int64 created_height = 7;
   */
  createdHeight = protoInt64.zero;

  /**
   * Encryption metadata for consensus-based encryption
   *
   * @generated from field: dwn.v1.EncryptionMetadata encryption_metadata = 8;
   */
  encryptionMetadata?: EncryptionMetadata;

  constructor(data?: PartialMessage<VaultState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dwn.v1.VaultState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vault_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "enclave_data", kind: "message", T: EnclaveData },
    { no: 4, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "created_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "last_refreshed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "created_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "encryption_metadata", kind: "message", T: EncryptionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VaultState {
    return new VaultState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VaultState {
    return new VaultState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VaultState {
    return new VaultState().fromJsonString(jsonString, options);
  }

  static equals(a: VaultState | PlainMessage<VaultState> | undefined, b: VaultState | PlainMessage<VaultState> | undefined): boolean {
    return proto3.util.equals(VaultState, a, b);
  }
}

