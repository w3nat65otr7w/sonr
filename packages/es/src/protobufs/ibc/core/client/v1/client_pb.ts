// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/core/client/v1/client.proto (package ibc.core.client.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * IdentifiedClientState defines a client state with an additional client
 * identifier field.
 *
 * @generated from message ibc.core.client.v1.IdentifiedClientState
 */
export class IdentifiedClientState extends Message<IdentifiedClientState> {
  /**
   * client identifier
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * client state
   *
   * @generated from field: google.protobuf.Any client_state = 2;
   */
  clientState?: Any;

  constructor(data?: PartialMessage<IdentifiedClientState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.IdentifiedClientState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "client_state", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifiedClientState {
    return new IdentifiedClientState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifiedClientState {
    return new IdentifiedClientState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifiedClientState {
    return new IdentifiedClientState().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifiedClientState | PlainMessage<IdentifiedClientState> | undefined, b: IdentifiedClientState | PlainMessage<IdentifiedClientState> | undefined): boolean {
    return proto3.util.equals(IdentifiedClientState, a, b);
  }
}

/**
 * ConsensusStateWithHeight defines a consensus state with an additional height
 * field.
 *
 * @generated from message ibc.core.client.v1.ConsensusStateWithHeight
 */
export class ConsensusStateWithHeight extends Message<ConsensusStateWithHeight> {
  /**
   * consensus state height
   *
   * @generated from field: ibc.core.client.v1.Height height = 1;
   */
  height?: Height;

  /**
   * consensus state
   *
   * @generated from field: google.protobuf.Any consensus_state = 2;
   */
  consensusState?: Any;

  constructor(data?: PartialMessage<ConsensusStateWithHeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.ConsensusStateWithHeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "message", T: Height },
    { no: 2, name: "consensus_state", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusStateWithHeight | PlainMessage<ConsensusStateWithHeight> | undefined, b: ConsensusStateWithHeight | PlainMessage<ConsensusStateWithHeight> | undefined): boolean {
    return proto3.util.equals(ConsensusStateWithHeight, a, b);
  }
}

/**
 * ClientConsensusStates defines all the stored consensus states for a given
 * client.
 *
 * @generated from message ibc.core.client.v1.ClientConsensusStates
 */
export class ClientConsensusStates extends Message<ClientConsensusStates> {
  /**
   * client identifier
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * consensus states and their heights associated with the client
   *
   * @generated from field: repeated ibc.core.client.v1.ConsensusStateWithHeight consensus_states = 2;
   */
  consensusStates: ConsensusStateWithHeight[] = [];

  constructor(data?: PartialMessage<ClientConsensusStates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.ClientConsensusStates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "consensus_states", kind: "message", T: ConsensusStateWithHeight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientConsensusStates {
    return new ClientConsensusStates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientConsensusStates {
    return new ClientConsensusStates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientConsensusStates {
    return new ClientConsensusStates().fromJsonString(jsonString, options);
  }

  static equals(a: ClientConsensusStates | PlainMessage<ClientConsensusStates> | undefined, b: ClientConsensusStates | PlainMessage<ClientConsensusStates> | undefined): boolean {
    return proto3.util.equals(ClientConsensusStates, a, b);
  }
}

/**
 * Height is a monotonically increasing data type
 * that can be compared against another Height for the purposes of updating and
 * freezing clients
 *
 * Normally the RevisionHeight is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionHeight
 * gets reset
 *
 * Please note that json tags for generated Go code are overridden to explicitly exclude the omitempty jsontag.
 * This enforces the Go json marshaller to always emit zero values for both revision_number and revision_height.
 *
 * @generated from message ibc.core.client.v1.Height
 */
export class Height extends Message<Height> {
  /**
   * the revision that the client is currently on
   *
   * @generated from field: uint64 revision_number = 1;
   */
  revisionNumber = protoInt64.zero;

  /**
   * the height within the given revision
   *
   * @generated from field: uint64 revision_height = 2;
   */
  revisionHeight = protoInt64.zero;

  constructor(data?: PartialMessage<Height>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.Height";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "revision_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "revision_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Height {
    return new Height().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Height {
    return new Height().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Height {
    return new Height().fromJsonString(jsonString, options);
  }

  static equals(a: Height | PlainMessage<Height> | undefined, b: Height | PlainMessage<Height> | undefined): boolean {
    return proto3.util.equals(Height, a, b);
  }
}

/**
 * Params defines the set of IBC light client parameters.
 *
 * @generated from message ibc.core.client.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * allowed_clients defines the list of allowed client state types which can be created
   * and interacted with. If a client type is removed from the allowed clients list, usage
   * of this client will be disabled until it is added again to the list.
   *
   * @generated from field: repeated string allowed_clients = 1;
   */
  allowedClients: string[] = [];

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_clients", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

