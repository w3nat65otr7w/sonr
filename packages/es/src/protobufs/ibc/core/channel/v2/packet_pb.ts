// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/core/channel/v2/packet.proto (package ibc.core.channel.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * PacketStatus specifies the status of a RecvPacketResult.
 *
 * @generated from enum ibc.core.channel.v2.PacketStatus
 */
export enum PacketStatus {
  /**
   * PACKET_STATUS_UNSPECIFIED indicates an unknown packet status.
   *
   * @generated from enum value: PACKET_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * PACKET_STATUS_SUCCESS indicates a successful packet receipt.
   *
   * @generated from enum value: PACKET_STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * PACKET_STATUS_FAILURE indicates a failed packet receipt.
   *
   * @generated from enum value: PACKET_STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * PACKET_STATUS_ASYNC indicates an async packet receipt.
   *
   * @generated from enum value: PACKET_STATUS_ASYNC = 3;
   */
  ASYNC = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PacketStatus)
proto3.util.setEnumType(PacketStatus, "ibc.core.channel.v2.PacketStatus", [
  { no: 0, name: "PACKET_STATUS_UNSPECIFIED" },
  { no: 1, name: "PACKET_STATUS_SUCCESS" },
  { no: 2, name: "PACKET_STATUS_FAILURE" },
  { no: 3, name: "PACKET_STATUS_ASYNC" },
]);

/**
 * Packet defines a type that carries data across different chains through IBC
 *
 * @generated from message ibc.core.channel.v2.Packet
 */
export class Packet extends Message<Packet> {
  /**
   * number corresponds to the order of sends and receives, where a Packet
   * with an earlier sequence number must be sent and received before a Packet
   * with a later sequence number.
   *
   * @generated from field: uint64 sequence = 1;
   */
  sequence = protoInt64.zero;

  /**
   * identifies the sending client on the sending chain.
   *
   * @generated from field: string source_client = 2;
   */
  sourceClient = "";

  /**
   * identifies the receiving client on the receiving chain.
   *
   * @generated from field: string destination_client = 3;
   */
  destinationClient = "";

  /**
   * timeout timestamp in seconds after which the packet times out.
   *
   * @generated from field: uint64 timeout_timestamp = 4;
   */
  timeoutTimestamp = protoInt64.zero;

  /**
   * a list of payloads, each one for a specific application.
   *
   * @generated from field: repeated ibc.core.channel.v2.Payload payloads = 5;
   */
  payloads: Payload[] = [];

  constructor(data?: PartialMessage<Packet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v2.Packet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "source_client", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "destination_client", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "timeout_timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "payloads", kind: "message", T: Payload, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Packet {
    return new Packet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Packet {
    return new Packet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Packet {
    return new Packet().fromJsonString(jsonString, options);
  }

  static equals(a: Packet | PlainMessage<Packet> | undefined, b: Packet | PlainMessage<Packet> | undefined): boolean {
    return proto3.util.equals(Packet, a, b);
  }
}

/**
 * Payload contains the source and destination ports and payload for the application (version, encoding, raw bytes)
 *
 * @generated from message ibc.core.channel.v2.Payload
 */
export class Payload extends Message<Payload> {
  /**
   * specifies the source port of the packet.
   *
   * @generated from field: string source_port = 1;
   */
  sourcePort = "";

  /**
   * specifies the destination port of the packet.
   *
   * @generated from field: string destination_port = 2;
   */
  destinationPort = "";

  /**
   * version of the specified application.
   *
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * the encoding used for the provided value.
   *
   * @generated from field: string encoding = 4;
   */
  encoding = "";

  /**
   * the raw bytes for the payload.
   *
   * @generated from field: bytes value = 5;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Payload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v2.Payload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "encoding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payload {
    return new Payload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJsonString(jsonString, options);
  }

  static equals(a: Payload | PlainMessage<Payload> | undefined, b: Payload | PlainMessage<Payload> | undefined): boolean {
    return proto3.util.equals(Payload, a, b);
  }
}

/**
 * Acknowledgement contains a list of all ack results associated with a single packet.
 * In the case of a successful receive, the acknowledgement will contain an app acknowledgement
 * for each application that received a payload in the same order that the payloads were sent
 * in the packet.
 * If the receive is not successful, the acknowledgement will contain a single app acknowledgment
 * which will be a constant error acknowledgment as defined by the IBC v2 protocol.
 *
 * @generated from message ibc.core.channel.v2.Acknowledgement
 */
export class Acknowledgement extends Message<Acknowledgement> {
  /**
   * @generated from field: repeated bytes app_acknowledgements = 1;
   */
  appAcknowledgements: Uint8Array[] = [];

  constructor(data?: PartialMessage<Acknowledgement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v2.Acknowledgement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app_acknowledgements", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Acknowledgement {
    return new Acknowledgement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Acknowledgement {
    return new Acknowledgement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Acknowledgement {
    return new Acknowledgement().fromJsonString(jsonString, options);
  }

  static equals(a: Acknowledgement | PlainMessage<Acknowledgement> | undefined, b: Acknowledgement | PlainMessage<Acknowledgement> | undefined): boolean {
    return proto3.util.equals(Acknowledgement, a, b);
  }
}

/**
 * RecvPacketResult speecifies the status of a packet as well as the acknowledgement bytes.
 *
 * @generated from message ibc.core.channel.v2.RecvPacketResult
 */
export class RecvPacketResult extends Message<RecvPacketResult> {
  /**
   * status of the packet
   *
   * @generated from field: ibc.core.channel.v2.PacketStatus status = 1;
   */
  status = PacketStatus.UNSPECIFIED;

  /**
   * acknowledgement of the packet
   *
   * @generated from field: bytes acknowledgement = 2;
   */
  acknowledgement = new Uint8Array(0);

  constructor(data?: PartialMessage<RecvPacketResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.channel.v2.RecvPacketResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(PacketStatus) },
    { no: 2, name: "acknowledgement", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecvPacketResult {
    return new RecvPacketResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecvPacketResult {
    return new RecvPacketResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecvPacketResult {
    return new RecvPacketResult().fromJsonString(jsonString, options);
  }

  static equals(a: RecvPacketResult | PlainMessage<RecvPacketResult> | undefined, b: RecvPacketResult | PlainMessage<RecvPacketResult> | undefined): boolean {
    return proto3.util.equals(RecvPacketResult, a, b);
  }
}

