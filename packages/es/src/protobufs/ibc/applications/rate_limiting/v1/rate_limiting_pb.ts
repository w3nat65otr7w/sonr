// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/applications/rate_limiting/v1/rate_limiting.proto (package ibc.applications.rate_limiting.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * PacketDirection defines whether the transfer packet is being sent from
 * this chain or is being received on this chain
 *
 * @generated from enum ibc.applications.rate_limiting.v1.PacketDirection
 */
export enum PacketDirection {
  /**
   * @generated from enum value: PACKET_SEND = 0;
   */
  PACKET_SEND = 0,

  /**
   * @generated from enum value: PACKET_RECV = 1;
   */
  PACKET_RECV = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(PacketDirection)
proto3.util.setEnumType(PacketDirection, "ibc.applications.rate_limiting.v1.PacketDirection", [
  { no: 0, name: "PACKET_SEND" },
  { no: 1, name: "PACKET_RECV" },
]);

/**
 * Path holds the denom and channelID that define the rate limited route
 *
 * @generated from message ibc.applications.rate_limiting.v1.Path
 */
export class Path extends Message<Path> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: string channel_or_client_id = 2;
   */
  channelOrClientId = "";

  constructor(data?: PartialMessage<Path>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.applications.rate_limiting.v1.Path";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "channel_or_client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Path {
    return new Path().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Path {
    return new Path().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Path {
    return new Path().fromJsonString(jsonString, options);
  }

  static equals(a: Path | PlainMessage<Path> | undefined, b: Path | PlainMessage<Path> | undefined): boolean {
    return proto3.util.equals(Path, a, b);
  }
}

/**
 * Quota defines the rate limit thresholds for transfer packets
 *
 * @generated from message ibc.applications.rate_limiting.v1.Quota
 */
export class Quota extends Message<Quota> {
  /**
   * MaxPercentSend defines the threshold for outflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   *
   * @generated from field: string max_percent_send = 1;
   */
  maxPercentSend = "";

  /**
   * MaxPercentSend defines the threshold for inflows
   * The threshold is defined as a percentage (e.g. 10 indicates 10%)
   *
   * @generated from field: string max_percent_recv = 2;
   */
  maxPercentRecv = "";

  /**
   * DurationHours specifies the number of hours before the rate limit
   * is reset (e.g. 24 indicates that the rate limit is reset each day)
   *
   * @generated from field: uint64 duration_hours = 3;
   */
  durationHours = protoInt64.zero;

  constructor(data?: PartialMessage<Quota>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.applications.rate_limiting.v1.Quota";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_percent_send", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "max_percent_recv", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "duration_hours", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quota {
    return new Quota().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quota {
    return new Quota().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quota {
    return new Quota().fromJsonString(jsonString, options);
  }

  static equals(a: Quota | PlainMessage<Quota> | undefined, b: Quota | PlainMessage<Quota> | undefined): boolean {
    return proto3.util.equals(Quota, a, b);
  }
}

/**
 * Flow tracks all the inflows and outflows of a channel.
 *
 * @generated from message ibc.applications.rate_limiting.v1.Flow
 */
export class Flow extends Message<Flow> {
  /**
   * Inflow defines the total amount of inbound transfers for the given
   * rate limit in the current window
   *
   * @generated from field: string inflow = 1;
   */
  inflow = "";

  /**
   * Outflow defines the total amount of outbound transfers for the given
   * rate limit in the current window
   *
   * @generated from field: string outflow = 2;
   */
  outflow = "";

  /**
   * ChannelValue stores the total supply of the denom at the start of
   * the rate limit. This is used as the denominator when checking
   * the rate limit threshold
   * The ChannelValue is fixed for the duration of the rate limit window
   *
   * @generated from field: string channel_value = 3;
   */
  channelValue = "";

  constructor(data?: PartialMessage<Flow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.applications.rate_limiting.v1.Flow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inflow", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "outflow", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "channel_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Flow {
    return new Flow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Flow {
    return new Flow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Flow {
    return new Flow().fromJsonString(jsonString, options);
  }

  static equals(a: Flow | PlainMessage<Flow> | undefined, b: Flow | PlainMessage<Flow> | undefined): boolean {
    return proto3.util.equals(Flow, a, b);
  }
}

/**
 * RateLimit stores all the context about a given rate limit, including
 * the relevant denom and channel, rate limit thresholds, and current
 * progress towards the limits
 *
 * @generated from message ibc.applications.rate_limiting.v1.RateLimit
 */
export class RateLimit extends Message<RateLimit> {
  /**
   * @generated from field: ibc.applications.rate_limiting.v1.Path path = 1;
   */
  path?: Path;

  /**
   * @generated from field: ibc.applications.rate_limiting.v1.Quota quota = 2;
   */
  quota?: Quota;

  /**
   * @generated from field: ibc.applications.rate_limiting.v1.Flow flow = 3;
   */
  flow?: Flow;

  constructor(data?: PartialMessage<RateLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.applications.rate_limiting.v1.RateLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "message", T: Path },
    { no: 2, name: "quota", kind: "message", T: Quota },
    { no: 3, name: "flow", kind: "message", T: Flow },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit {
    return new RateLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJsonString(jsonString, options);
  }

  static equals(a: RateLimit | PlainMessage<RateLimit> | undefined, b: RateLimit | PlainMessage<RateLimit> | undefined): boolean {
    return proto3.util.equals(RateLimit, a, b);
  }
}

/**
 * WhitelistedAddressPair represents a sender-receiver combo that is
 * not subject to rate limit restrictions
 *
 * @generated from message ibc.applications.rate_limiting.v1.WhitelistedAddressPair
 */
export class WhitelistedAddressPair extends Message<WhitelistedAddressPair> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string receiver = 2;
   */
  receiver = "";

  constructor(data?: PartialMessage<WhitelistedAddressPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.applications.rate_limiting.v1.WhitelistedAddressPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistedAddressPair {
    return new WhitelistedAddressPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistedAddressPair {
    return new WhitelistedAddressPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistedAddressPair {
    return new WhitelistedAddressPair().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistedAddressPair | PlainMessage<WhitelistedAddressPair> | undefined, b: WhitelistedAddressPair | PlainMessage<WhitelistedAddressPair> | undefined): boolean {
    return proto3.util.equals(WhitelistedAddressPair, a, b);
  }
}

/**
 * HourEpoch is the epoch type.
 *
 * @generated from message ibc.applications.rate_limiting.v1.HourEpoch
 */
export class HourEpoch extends Message<HourEpoch> {
  /**
   * @generated from field: uint64 epoch_number = 1;
   */
  epochNumber = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Duration duration = 2;
   */
  duration?: Duration;

  /**
   * @generated from field: google.protobuf.Timestamp epoch_start_time = 3;
   */
  epochStartTime?: Timestamp;

  /**
   * @generated from field: int64 epoch_start_height = 4;
   */
  epochStartHeight = protoInt64.zero;

  constructor(data?: PartialMessage<HourEpoch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.applications.rate_limiting.v1.HourEpoch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "duration", kind: "message", T: Duration },
    { no: 3, name: "epoch_start_time", kind: "message", T: Timestamp },
    { no: 4, name: "epoch_start_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HourEpoch {
    return new HourEpoch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HourEpoch {
    return new HourEpoch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HourEpoch {
    return new HourEpoch().fromJsonString(jsonString, options);
  }

  static equals(a: HourEpoch | PlainMessage<HourEpoch> | undefined, b: HourEpoch | PlainMessage<HourEpoch> | undefined): boolean {
    return proto3.util.equals(HourEpoch, a, b);
  }
}

